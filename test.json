{
    "mechanics": {
        "bullets": {
            "examples": {
                "aiming": {
                    "notes": "Click or tap to fire a bullet. Hold to fire multiple bullets.\n\nBullets will fire in the direction of the pointer or tap.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('bullet', '/assets/gfx/bullet.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define constants\n    this.SHOT_DELAY = 100; // milliseconds (10 bullets/second)\n    this.BULLET_SPEED = 500; // pixels/second\n    this.NUMBER_OF_BULLETS = 20;\n\n    // Create an object representing our gun\n    this.gun = this.game.add.sprite(50, this.game.height/2, 'bullet');\n\n    // Set the pivot point to the center of the gun\n    this.gun.anchor.setTo(0.5, 0.5);\n\n    // Create an object pool of bullets\n    this.bulletPool = this.game.add.group();\n    for(var i = 0; i < this.NUMBER_OF_BULLETS; i++) {\n        // Create each bullet and add it to the group.\n        var bullet = this.game.add.sprite(0, 0, 'bullet');\n        this.bulletPool.add(bullet);\n\n        // Set its pivot point to the center of the bullet\n        bullet.anchor.setTo(0.5, 0.5);\n\n        // Enable physics on the bullet\n        this.game.physics.enable(bullet, Phaser.Physics.ARCADE);\n\n        // Set its initial state to \"dead\".\n        bullet.kill();\n    }\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.activePointer.x = this.game.width/2;\n    this.game.input.activePointer.y = this.game.height/2;\n};\n\nGameState.prototype.shootBullet = function() {\n    // Enforce a short delay between shots by recording\n    // the time that each bullet is shot and testing if\n    // the amount of time since the last shot is more than\n    // the required delay.\n    if (this.lastBulletShotAt === undefined) this.lastBulletShotAt = 0;\n    if (this.game.time.now - this.lastBulletShotAt < this.SHOT_DELAY) return;\n    this.lastBulletShotAt = this.game.time.now;\n\n    // Get a dead bullet from the pool\n    var bullet = this.bulletPool.getFirstDead();\n\n    // If there aren't any bullets available then don't shoot\n    if (bullet === null || bullet === undefined) return;\n\n    // Revive the bullet\n    // This makes the bullet \"alive\"\n    bullet.revive();\n\n    // Bullets should kill themselves when they leave the world.\n    // Phaser takes care of this for me by setting this flag\n    // but you can do it yourself by killing the bullet if\n    // its x,y coordinates are outside of the world.\n    bullet.checkWorldBounds = true;\n    bullet.outOfBoundsKill = true;\n\n    // Set the bullet position to the gun position.\n    bullet.reset(this.gun.x, this.gun.y);\n    bullet.rotation = this.gun.rotation;\n\n    // Shoot it in the right direction\n    bullet.body.velocity.x = Math.cos(bullet.rotation) * this.BULLET_SPEED;\n    bullet.body.velocity.y = Math.sin(bullet.rotation) * this.BULLET_SPEED;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Aim the gun at the pointer.\n    // All this function does is calculate the angle using\n    // Math.atan2(yPointer-yGun, xPointer-xGun)\n    this.gun.rotation = this.game.physics.arcade.angleToPointer(this.gun);\n\n    // Shoot a bullet\n    if (this.game.input.activePointer.isDown) {\n        this.shootBullet();\n    }\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "rapid_fire": {
                    "notes": "Click or tap to fire a bullet. Hold to fire multiple bullets.\n\nWe can enable rapid fire simply by increasing the number of available bullets in the bulletPool.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('bullet', '/assets/gfx/bullet.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define constants\n    this.SHOT_DELAY = 100; // milliseconds (10 bullets/second)\n    this.BULLET_SPEED = 500; // pixels/second\n    this.NUMBER_OF_BULLETS = 20;\n\n    // Create an object representing our gun\n    this.gun = this.game.add.sprite(50, this.game.height/2, 'bullet');\n\n    // Set the pivot point to the center of the gun\n    this.gun.anchor.setTo(0.5, 0.5);\n\n    // Create an object pool of bullets\n    this.bulletPool = this.game.add.group();\n    for(var i = 0; i < this.NUMBER_OF_BULLETS; i++) {\n        // Create each bullet and add it to the group.\n        var bullet = this.game.add.sprite(0, 0, 'bullet');\n        this.bulletPool.add(bullet);\n\n        // Set its pivot point to the center of the bullet\n        bullet.anchor.setTo(0.5, 0.5);\n\n        // Enable physics on the bullet\n        this.game.physics.enable(bullet, Phaser.Physics.ARCADE);\n\n        // Set its initial state to \"dead\".\n        bullet.kill();\n    }\n};\n\nGameState.prototype.shootBullet = function() {\n    // Enforce a short delay between shots by recording\n    // the time that each bullet is shot and testing if\n    // the amount of time since the last shot is more than\n    // the required delay.\n    if (this.lastBulletShotAt === undefined) this.lastBulletShotAt = 0;\n    if (this.game.time.now - this.lastBulletShotAt < this.SHOT_DELAY) return;\n    this.lastBulletShotAt = this.game.time.now;\n\n    // Get a dead bullet from the pool\n    var bullet = this.bulletPool.getFirstDead();\n\n    // If there aren't any bullets available then don't shoot\n    if (bullet === null || bullet === undefined) return;\n\n    // Revive the bullet\n    // This makes the bullet \"alive\"\n    bullet.revive();\n\n    // Bullets should kill themselves when they leave the world.\n    // Phaser takes care of this for me by setting this flag\n    // but you can do it yourself by killing the bullet if\n    // its x,y coordinates are outside of the world.\n    bullet.checkWorldBounds = true;\n    bullet.outOfBoundsKill = true;\n\n    // Set the bullet position to the gun position.\n    bullet.reset(this.gun.x, this.gun.y);\n\n    // Shoot it\n    bullet.body.velocity.x = this.BULLET_SPEED;\n    bullet.body.velocity.y = 0;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Shoot a bullet\n    if (this.game.input.activePointer.isDown) {\n        this.shootBullet();\n    }\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "single_shot": {
                    "notes": "Click or tap to fire a bullet.\n\nHere we fire a single bullet and only a single bullet may be on screen at any time. This example also shows how to use an object pool to recycle bullet objects. Recycling objects in this way is essential for good performance. Because there is only one bullet in this pool, only one bullet can appear at any given time.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('bullet', '/assets/gfx/bullet.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define constants\n    this.SHOT_DELAY = 100; // milliseconds (10 bullets/second)\n    this.BULLET_SPEED = 500; // pixels/second\n    this.NUMBER_OF_BULLETS = 1;\n\n    // Create an object representing our gun\n    this.gun = this.game.add.sprite(50, this.game.height/2, 'bullet');\n\n    // Set the pivot point to the center of the gun\n    this.gun.anchor.setTo(0.5, 0.5);\n\n    // Create an object pool of bullets\n    this.bulletPool = this.game.add.group();\n    for(var i = 0; i < this.NUMBER_OF_BULLETS; i++) {\n        // Create each bullet and add it to the group.\n        var bullet = this.game.add.sprite(0, 0, 'bullet');\n        this.bulletPool.add(bullet);\n\n        // Set its pivot point to the center of the bullet\n        bullet.anchor.setTo(0.5, 0.5);\n\n        // Enable physics on the bullet\n        this.game.physics.enable(bullet, Phaser.Physics.ARCADE);\n\n        // Set its initial state to \"dead\".\n        bullet.kill();\n    }\n};\n\nGameState.prototype.shootBullet = function() {\n    // Enforce a short delay between shots by recording\n    // the time that each bullet is shot and testing if\n    // the amount of time since the last shot is more than\n    // the required delay.\n    if (this.lastBulletShotAt === undefined) this.lastBulletShotAt = 0;\n    if (this.game.time.now - this.lastBulletShotAt < this.SHOT_DELAY) return;\n    this.lastBulletShotAt = this.game.time.now;\n\n    // Get a dead bullet from the pool\n    var bullet = this.bulletPool.getFirstDead();\n\n    // If there aren't any bullets available then don't shoot\n    if (bullet === null || bullet === undefined) return;\n\n    // Revive the bullet\n    // This makes the bullet \"alive\"\n    bullet.revive();\n\n    // Bullets should kill themselves when they leave the world.\n    // Phaser takes care of this for me by setting this flag\n    // but you can do it yourself by killing the bullet if\n    // its x,y coordinates are outside of the world.\n    bullet.checkWorldBounds = true;\n    bullet.outOfBoundsKill = true;\n\n    // Set the bullet position to the gun position.\n    bullet.reset(this.gun.x, this.gun.y);\n\n    // Shoot it\n    bullet.body.velocity.x = this.BULLET_SPEED;\n    bullet.body.velocity.y = 0;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Shoot a bullet\n    if (this.game.input.activePointer.isDown) {\n        this.shootBullet();\n    }\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "artillary": {
                    "notes": "Click or tap to fire an artillery shell. Hold to fire multiple shots.\n\nThese bullets are affected by gravity so they make a parabolic arc to their target.\n\nThis example introduces a function getExplosion() which either creates a new explosion object or re-uses one that was created earlier. This approach allows the number of explosion sprites to increase dynamically but never creates more than are needed to display on screen at any one time.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('bullet', '/assets/gfx/bullet.png');\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.spritesheet('explosion', '/assets/gfx/explosion.png', 128, 128);\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define constants\n    this.SHOT_DELAY = 300; // milliseconds (10 bullets/3 seconds)\n    this.BULLET_SPEED = 800; // pixels/second\n    this.NUMBER_OF_BULLETS = 20;\n    this.GRAVITY = 980; // pixels/second/second\n\n    // Create an object representing our gun\n    this.gun = this.game.add.sprite(50, this.game.height - 64, 'bullet');\n\n    // Set the pivot point to the center of the gun\n    this.gun.anchor.setTo(0.5, 0.5);\n\n    // Create an object pool of bullets\n    this.bulletPool = this.game.add.group();\n    for(var i = 0; i < this.NUMBER_OF_BULLETS; i++) {\n        // Create each bullet and add it to the group.\n        var bullet = this.game.add.sprite(0, 0, 'bullet');\n        this.bulletPool.add(bullet);\n\n        // Set its pivot point to the center of the bullet\n        bullet.anchor.setTo(0.5, 0.5);\n\n        // Enable physics on the bullet\n        this.game.physics.enable(bullet, Phaser.Physics.ARCADE);\n\n        // Set its initial state to \"dead\".\n        bullet.kill();\n    }\n\n    // Turn on gravity\n    game.physics.arcade.gravity.y = this.GRAVITY;\n\n    // Create some ground\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n\n    // Create a group for explosions\n    this.explosionGroup = this.game.add.group();\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.activePointer.x = this.game.width/2;\n    this.game.input.activePointer.y = this.game.height/2 - 100;\n};\n\nGameState.prototype.shootBullet = function() {\n    // Enforce a short delay between shots by recording\n    // the time that each bullet is shot and testing if\n    // the amount of time since the last shot is more than\n    // the required delay.\n    if (this.lastBulletShotAt === undefined) this.lastBulletShotAt = 0;\n    if (this.game.time.now - this.lastBulletShotAt < this.SHOT_DELAY) return;\n    this.lastBulletShotAt = this.game.time.now;\n\n    // Get a dead bullet from the pool\n    var bullet = this.bulletPool.getFirstDead();\n\n    // If there aren't any bullets available then don't shoot\n    if (bullet === null || bullet === undefined) return;\n\n    // Revive the bullet\n    // This makes the bullet \"alive\"\n    bullet.revive();\n\n    // Bullets should kill themselves when they leave the world.\n    // Phaser takes care of this for me by setting this flag\n    // but you can do it yourself by killing the bullet if\n    // its x,y coordinates are outside of the world.\n    bullet.checkWorldBounds = true;\n    bullet.outOfBoundsKill = true;\n\n    // Set the bullet position to the gun position.\n    bullet.reset(this.gun.x, this.gun.y);\n    bullet.rotation = this.gun.rotation;\n\n    // Shoot it in the right direction\n    bullet.body.velocity.x = Math.cos(bullet.rotation) * this.BULLET_SPEED;\n    bullet.body.velocity.y = Math.sin(bullet.rotation) * this.BULLET_SPEED;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Check if bullets have collided with the ground\n    this.game.physics.arcade.collide(this.bulletPool, this.ground, function(bullet, ground) {\n        // Create an explosion\n        this.getExplosion(bullet.x, bullet.y);\n\n        // Kill the bullet\n        bullet.kill();\n    }, null, this);\n\n    // Rotate all living bullets to match their trajectory\n    this.bulletPool.forEachAlive(function(bullet) {\n        bullet.rotation = Math.atan2(bullet.body.velocity.y, bullet.body.velocity.x);\n    }, this);\n\n    // Aim the gun at the pointer.\n    // All this function does is calculate the angle using\n    // Math.atan2(yPointer-yGun, xPointer-xGun)\n    this.gun.rotation = this.game.physics.arcade.angleToPointer(this.gun);\n\n    // Shoot a bullet\n    if (this.game.input.activePointer.isDown) {\n        this.shootBullet();\n    }\n};\n\n// Try to get a used explosion from the explosionGroup.\n// If an explosion isn't available, create a new one and add it to the group.\n// Setup new explosions so that they animate and kill themselves when the\n// animation is complete.\nGameState.prototype.getExplosion = function(x, y) {\n    // Get the first dead explosion from the explosionGroup\n    var explosion = this.explosionGroup.getFirstDead();\n\n    // If there aren't any available, create a new one\n    if (explosion === null) {\n        explosion = this.game.add.sprite(0, 0, 'explosion');\n        explosion.anchor.setTo(0.5, 0.5);\n\n        // Add an animation for the explosion that kills the sprite when the\n        // animation is complete\n        var animation = explosion.animations.add('boom', [0,1,2,3], 60, false);\n        animation.killOnComplete = true;\n\n        // Add the explosion sprite to the group\n        this.explosionGroup.add(explosion);\n    }\n\n    // Revive the explosion (set it's alive property to true)\n    // You can also define a onRevived event handler in your explosion objects\n    // to do stuff when they are revived.\n    explosion.revive();\n\n    // Move the explosion to the given coordinates\n    explosion.x = x;\n    explosion.y = y;\n\n    // Set rotation of the explosion at random for a little variety\n    explosion.angle = this.game.rnd.integerInRange(0, 360);\n\n    // Play the animation\n    explosion.animations.play('boom');\n\n    // Return the explosion itself in case we want to do anything else with it\n    return explosion;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "display_trajectory": {
                    "notes": "Click or tap to fire an artillery shell. Hold to fire multiple shots.\n\nThe trajectory is calculated and plotted based on the firing angle, gravity, and initial bullet velocity.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('bullet', '/assets/gfx/bullet.png');\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.spritesheet('explosion', '/assets/gfx/explosion.png', 128, 128);\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define constants\n    this.SHOT_DELAY = 300; // milliseconds (10 bullets/3 seconds)\n    this.BULLET_SPEED = 800; // pixels/second\n    this.NUMBER_OF_BULLETS = 20;\n    this.GRAVITY = 980; // pixels/second/second\n\n    // Create an object representing our gun\n    this.gun = this.game.add.sprite(50, this.game.height - 64, 'bullet');\n\n    // Set the pivot point to the center of the gun\n    this.gun.anchor.setTo(0.5, 0.5);\n\n    // Create an object pool of bullets\n    this.bulletPool = this.game.add.group();\n    for(var i = 0; i < this.NUMBER_OF_BULLETS; i++) {\n        // Create each bullet and add it to the group.\n        var bullet = this.game.add.sprite(0, 0, 'bullet');\n        this.bulletPool.add(bullet);\n\n        // Set its pivot point to the center of the bullet\n        bullet.anchor.setTo(0.5, 0.5);\n\n        // Enable physics on the bullet\n        this.game.physics.enable(bullet, Phaser.Physics.ARCADE);\n\n        // Set its initial state to \"dead\".\n        bullet.kill();\n    }\n\n    // Turn on gravity\n    game.physics.arcade.gravity.y = this.GRAVITY;\n\n    // Create some ground\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n\n    // Create a group for explosions\n    this.explosionGroup = this.game.add.group();\n\n    // Setup a canvas to draw the trajectory on the screen\n    this.bitmap = this.game.add.bitmapData(this.game.width, this.game.height);\n    this.bitmap.context.fillStyle = 'rgb(255, 255, 255)';\n    this.bitmap.context.strokeStyle = 'rgb(255, 255, 255)';\n    this.game.add.image(0, 0, this.bitmap);\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.activePointer.x = this.game.width/2;\n    this.game.input.activePointer.y = this.game.height/2 - 100;\n};\n\nGameState.prototype.drawTrajectory = function() {\n    // Clear the bitmap\n    this.bitmap.context.clearRect(0, 0, this.game.width, this.game.height);\n\n    // Set fill style to white\n    this.bitmap.context.fillStyle = 'rgba(255, 255, 255, 0.5)';\n\n    // Calculate a time offset. This offset is used to alter the starting\n    // time of the draw loop so that the dots are offset a little bit each\n    // frame. It gives the trajectory a \"marching ants\" style animation.\n    var MARCH_SPEED = 40; // Smaller is faster\n    this.timeOffset = this.timeOffset + 1 || 0;\n    this.timeOffset = this.timeOffset % MARCH_SPEED;\n\n    // Just a variable to make the trajectory match the actual track a little better.\n    // The mismatch is probably due to rounding or the physics engine making approximations.\n    var correctionFactor = 0.99;\n\n    // Draw the trajectory\n    // http://en.wikipedia.org/wiki/Trajectory_of_a_projectile#Angle_required_to_hit_coordinate_.28x.2Cy.29\n    var theta = -this.gun.rotation;\n    var x = 0, y = 0;\n    for(var t = 0 + this.timeOffset/(1000*MARCH_SPEED/60); t < 3; t += 0.03) {\n        x = this.BULLET_SPEED * t * Math.cos(theta) * correctionFactor;\n        y = this.BULLET_SPEED * t * Math.sin(theta) * correctionFactor - 0.5 * this.GRAVITY * t * t;\n        this.bitmap.context.fillRect(x + this.gun.x, this.gun.y - y, 3, 3);\n        if (y < -15) break;\n    }\n\n    this.bitmap.dirty = true;\n};\n\nGameState.prototype.shootBullet = function() {\n    // Enforce a short delay between shots by recording\n    // the time that each bullet is shot and testing if\n    // the amount of time since the last shot is more than\n    // the required delay.\n    if (this.lastBulletShotAt === undefined) this.lastBulletShotAt = 0;\n    if (this.game.time.now - this.lastBulletShotAt < this.SHOT_DELAY) return;\n    this.lastBulletShotAt = this.game.time.now;\n\n    // Get a dead bullet from the pool\n    var bullet = this.bulletPool.getFirstDead();\n\n    // If there aren't any bullets available then don't shoot\n    if (bullet === null || bullet === undefined) return;\n\n    // Revive the bullet\n    // This makes the bullet \"alive\"\n    bullet.revive();\n\n    // Bullets should kill themselves when they leave the world.\n    // Phaser takes care of this for me by setting this flag\n    // but you can do it yourself by killing the bullet if\n    // its x,y coordinates are outside of the world.\n    bullet.checkWorldBounds = true;\n    bullet.outOfBoundsKill = true;\n\n    // Set the bullet position to the gun position.\n    bullet.reset(this.gun.x, this.gun.y);\n    bullet.rotation = this.gun.rotation;\n\n    // Shoot it in the right direction\n    bullet.body.velocity.x = Math.cos(bullet.rotation) * this.BULLET_SPEED;\n    bullet.body.velocity.y = Math.sin(bullet.rotation) * this.BULLET_SPEED;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Draw the trajectory every frame\n    this.drawTrajectory();\n\n    // Check if bullets have collided with the ground\n    this.game.physics.arcade.collide(this.bulletPool, this.ground, function(bullet, ground) {\n        // Create an explosion\n        this.getExplosion(bullet.x, bullet.y);\n\n        // Kill the bullet\n        bullet.kill();\n    }, null, this);\n\n    // Rotate all living bullets to match their trajectory\n    this.bulletPool.forEachAlive(function(bullet) {\n        bullet.rotation = Math.atan2(bullet.body.velocity.y, bullet.body.velocity.x);\n    }, this);\n\n    // Aim the gun at the pointer.\n    // All this function does is calculate the angle using\n    // Math.atan2(yPointer-yGun, xPointer-xGun)\n    this.gun.rotation = this.game.physics.arcade.angleToPointer(this.gun);\n\n    // Shoot a bullet\n    if (this.game.input.activePointer.isDown) {\n        this.shootBullet();\n    }\n};\n\n// Try to get a used explosion from the explosionGroup.\n// If an explosion isn't available, create a new one and add it to the group.\n// Setup new explosions so that they animate and kill themselves when the\n// animation is complete.\nGameState.prototype.getExplosion = function(x, y) {\n    // Get the first dead explosion from the explosionGroup\n    var explosion = this.explosionGroup.getFirstDead();\n\n    // If there aren't any available, create a new one\n    if (explosion === null) {\n        explosion = this.game.add.sprite(0, 0, 'explosion');\n        explosion.anchor.setTo(0.5, 0.5);\n\n        // Add an animation for the explosion that kills the sprite when the\n        // animation is complete\n        var animation = explosion.animations.add('boom', [0,1,2,3], 60, false);\n        animation.killOnComplete = true;\n\n        // Add the explosion sprite to the group\n        this.explosionGroup.add(explosion);\n    }\n\n    // Revive the explosion (set it's alive property to true)\n    // You can also define a onRevived event handler in your explosion objects\n    // to do stuff when they are revived.\n    explosion.revive();\n\n    // Move the explosion to the given coordinates\n    explosion.x = x;\n    explosion.y = y;\n\n    // Set rotation of the explosion at random for a little variety\n    explosion.angle = this.game.rnd.integerInRange(0, 360);\n\n    // Play the animation\n    explosion.animations.play('boom');\n\n    // Return the explosion itself in case we want to do anything else with it\n    return explosion;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                }
            },
            "assets": [
                "/assets/gfx/bullet.png",
                "/assets/gfx/ground.png",
                "/assets/gfx/explosion.png"
            ]
        },
        "walking_and_jumping": {
            "examples": {
                "with_drag": {
                    "notes": "Use the arrow keys or tap to move the player left and right.\n\nThe player now has a DRAG component. DRAG works by applying a velocity in the opposite direction of the player movement whenever the player is not accelerating. This causes the player to slow down gradually when no keys are pressed. Note that ACCELERATION is greater than DRAG. This allows the player to slow down and change direction faster by pressing the opposite arrow key; or to coast to a stop by releasing all of the keys.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.image('player', '/assets/gfx/player.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define movement constants\n    this.MAX_SPEED = 500; // pixels/second\n    this.ACCELERATION = 1500; // pixels/second/second\n    this.DRAG = 600; // pixels/second\n\n    // Create a player sprite\n    this.player = this.game.add.sprite(this.game.width/2, this.game.height - 64, 'player');\n\n    // Enable physics on the player\n    this.game.physics.enable(this.player, Phaser.Physics.ARCADE);\n\n    // Make player collide with world boundaries so he doesn't leave the stage\n    this.player.body.collideWorldBounds = true;\n\n    // Set player maximum movement speed\n    this.player.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED); // x, y\n\n    // Add drag to the player that slows them down when they are not accelerating\n    this.player.body.drag.setTo(this.DRAG, 0); // x, y\n\n    // Create some ground for the player to walk on\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Collide the player with the ground\n    this.game.physics.arcade.collide(this.player, this.ground);\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, set the player velocity to move left\n        this.player.body.acceleration.x = -this.ACCELERATION;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, set the player velocity to move right\n        this.player.body.acceleration.x = this.ACCELERATION;\n    } else {\n        this.player.body.acceleration.x = 0;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "variable_jump_height": {
                    "notes": "Use the arrow keys or tap to move the player left and right. Press the up arrow or tap the center to jump and double jump (while in the air).\n\nYou can control the height of the jump by how long you hold down the jump button.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.image('player', '/assets/gfx/player.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define movement constants\n    this.MAX_SPEED = 500; // pixels/second\n    this.ACCELERATION = 1500; // pixels/second/second\n    this.DRAG = 600; // pixels/second\n    this.GRAVITY = 2600; // pixels/second/second\n    this.JUMP_SPEED = -700; // pixels/second (negative y is up)\n\n    // Create a player sprite\n    this.player = this.game.add.sprite(this.game.width/2, this.game.height - 64, 'player');\n\n    // Enable physics on the player\n    this.game.physics.enable(this.player, Phaser.Physics.ARCADE);\n\n    // Make player collide with world boundaries so he doesn't leave the stage\n    this.player.body.collideWorldBounds = true;\n\n    // Set player minimum and maximum movement speed\n    this.player.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED * 10); // x, y\n\n    // Add drag to the player that slows them down when they are not accelerating\n    this.player.body.drag.setTo(this.DRAG, 0); // x, y\n\n    // Since we're jumping we need gravity\n    game.physics.arcade.gravity.y = this.GRAVITY;\n\n    // Flag to track if the jump button is pressed\n    this.jumping = false;\n\n    // Create some ground for the player to walk on\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n\n    // Just for fun, draw some height markers so we can see how high we're jumping\n    this.drawHeightMarkers();\n};\n\n// This function draws horizontal lines across the stage\nGameState.prototype.drawHeightMarkers = function() {\n    // Create a bitmap the same size as the stage\n    var bitmap = this.game.add.bitmapData(this.game.width, this.game.height);\n\n    // These functions use the canvas context to draw lines using the canvas API\n    for(y = this.game.height-32; y >= 64; y -= 32) {\n        bitmap.context.beginPath();\n        bitmap.context.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n        bitmap.context.moveTo(0, y);\n        bitmap.context.lineTo(this.game.width, y);\n        bitmap.context.stroke();\n    }\n\n    this.game.add.image(0, 0, bitmap);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Collide the player with the ground\n    this.game.physics.arcade.collide(this.player, this.ground);\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, set the player velocity to move left\n        this.player.body.acceleration.x = -this.ACCELERATION;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, set the player velocity to move right\n        this.player.body.acceleration.x = this.ACCELERATION;\n    } else {\n        this.player.body.acceleration.x = 0;\n    }\n\n    // Set a variable that is true when the player is touching the ground\n    var onTheGround = this.player.body.touching.down;\n\n    // If the player is touching the ground, let him have 2 jumps\n    if (onTheGround) {\n        this.jumps = 2;\n        this.jumping = false;\n    }\n\n    // Jump! Keep y velocity constant while the jump button is held for up to 150 ms\n    if (this.jumps > 0 && this.upInputIsActive(150)) {\n        this.player.body.velocity.y = this.JUMP_SPEED;\n        this.jumping = true;\n    }\n\n    // Reduce the number of available jumps if the jump input is released\n    if (this.jumping && this.upInputReleased()) {\n        this.jumps--;\n        this.jumping = false;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"jump\" control\n// In this case, either holding the up arrow or tapping or clicking on the center\n// part of the screen.\nGameState.prototype.upInputIsActive = function(duration) {\n    var isActive = false;\n\n    isActive = this.input.keyboard.downDuration(Phaser.Keyboard.UP, duration);\n    isActive |= (this.game.input.activePointer.justPressed(duration + 1000/60) &&\n        this.game.input.activePointer.x > this.game.width/4 &&\n        this.game.input.activePointer.x < this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\n// This function returns true when the player releases the \"jump\" control\nGameState.prototype.upInputReleased = function() {\n    var released = false;\n\n    released = this.input.keyboard.upDuration(Phaser.Keyboard.UP);\n    released |= this.game.input.activePointer.justReleased();\n\n    return released;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "jumping": {
                    "notes": "Use the arrow keys or tap to move the player left and right. Press the up arrow or tap the center to jump.\n\nJumping is a combination of two things: an upward velocity and gravity. When the up arrow is pressed and the player is touching the ground, an upward velocity is added to the player. Gravity then accelerates the character back towards the ground. The parabolic path of the player while jumping is simply a result of the player being affected by gravity.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.image('player', '/assets/gfx/player.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define movement constants\n    this.MAX_SPEED = 500; // pixels/second\n    this.ACCELERATION = 1500; // pixels/second/second\n    this.DRAG = 600; // pixels/second\n    this.GRAVITY = 2600; // pixels/second/second\n    this.JUMP_SPEED = -1000; // pixels/second (negative y is up)\n\n    // Create a player sprite\n    this.player = this.game.add.sprite(this.game.width/2, this.game.height - 64, 'player');\n\n    // Enable physics on the player\n    this.game.physics.enable(this.player, Phaser.Physics.ARCADE);\n\n    // Make player collide with world boundaries so he doesn't leave the stage\n    this.player.body.collideWorldBounds = true;\n\n    // Set player minimum and maximum movement speed\n    this.player.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED * 10); // x, y\n\n    // Add drag to the player that slows them down when they are not accelerating\n    this.player.body.drag.setTo(this.DRAG, 0); // x, y\n\n    // Since we're jumping we need gravity\n    game.physics.arcade.gravity.y = this.GRAVITY;\n\n    // Create some ground for the player to walk on\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n\n    // Just for fun, draw some height markers so we can see how high we're jumping\n    this.drawHeightMarkers();\n};\n\n// This function draws horizontal lines across the stage\nGameState.prototype.drawHeightMarkers = function() {\n    // Create a bitmap the same size as the stage\n    var bitmap = this.game.add.bitmapData(this.game.width, this.game.height);\n\n    // These functions use the canvas context to draw lines using the canvas API\n    for(y = this.game.height-32; y >= 64; y -= 32) {\n        bitmap.context.beginPath();\n        bitmap.context.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n        bitmap.context.moveTo(0, y);\n        bitmap.context.lineTo(this.game.width, y);\n        bitmap.context.stroke();\n    }\n\n    this.game.add.image(0, 0, bitmap);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Collide the player with the ground\n    this.game.physics.arcade.collide(this.player, this.ground);\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, set the player velocity to move left\n        this.player.body.acceleration.x = -this.ACCELERATION;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, set the player velocity to move right\n        this.player.body.acceleration.x = this.ACCELERATION;\n    } else {\n        this.player.body.acceleration.x = 0;\n    }\n\n    // Set a variable that is true when the player is touching the ground\n    var onTheGround = this.player.body.touching.down;\n\n    if (onTheGround && this.upInputIsActive()) {\n        // Jump when the player is touching the ground and the up arrow is pressed\n        this.player.body.velocity.y = this.JUMP_SPEED;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"jump\" control\n// In this case, either holding the up arrow or tapping or clicking on the center\n// part of the screen.\nGameState.prototype.upInputIsActive = function(duration) {\n    var isActive = false;\n\n    isActive = this.input.keyboard.downDuration(Phaser.Keyboard.UP, duration);\n    isActive |= (this.game.input.activePointer.justPressed(duration + 1000/60) &&\n        this.game.input.activePointer.x > this.game.width/4 &&\n        this.game.input.activePointer.x < this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "with_acceleration": {
                    "notes": "Use the arrow keys or tap to move the player left and right.\n\nThe player now gradually accelerates from zero to top speed while a key is pressed.\n\nDid you notice the side-effect caused by the way the movement is coded? If you hold RIGHT, release it, then hold LEFT, the player moves right, stops, then moves left. But if you hold RIGHT then start holding LEFT, the player will gradually change direction to the left. The code to stop the player is never called because a key is being held down at all times. And the player moves left when both keys are held down because LEFT is tested first. You can fix this by stopping the player whenever the movement direction changes. But look at the next example for a better solution.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.image('player', '/assets/gfx/player.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define movement constants\n    this.MAX_SPEED = 500; // pixels/second\n    this.ACCELERATION = 1500; // pixels/second/second\n\n    // Create a player sprite\n    this.player = this.game.add.sprite(this.game.width/2, this.game.height - 64, 'player');\n\n    // Enable physics on the player\n    this.game.physics.enable(this.player, Phaser.Physics.ARCADE);\n\n    // Make player collide with world boundaries so he doesn't leave the stage\n    this.player.body.collideWorldBounds = true;\n\n    // Set player maximum movement speed\n    this.player.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED); // x, y\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n\n    // Create some ground for the player to walk on\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Collide the player with the ground\n    this.game.physics.arcade.collide(this.player, this.ground);\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, set the player velocity to move left\n        this.player.body.acceleration.x = -this.ACCELERATION;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, set the player velocity to move right\n        this.player.body.acceleration.x = this.ACCELERATION;\n    } else {\n        // Stop the player from moving horizontally\n        this.player.body.acceleration.x = 0;\n        this.player.body.velocity.x = 0;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "basic_walking": {
                    "notes": "In this set of examples, we'll look at the components of platformer-style movement. Here, the movement is very simple: the player is either stopped or moving at full speed. It works but it doesn't feel very good.\n\nUse the arrow keys or tap to move the player left and right.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.image('player', '/assets/gfx/player.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define movement constants\n    this.MAX_SPEED = 500; // pixels/second\n\n    // Create a player sprite\n    this.player = this.game.add.sprite(this.game.width/2, this.game.height - 64, 'player');\n\n    // Enable physics on the player\n    this.game.physics.enable(this.player, Phaser.Physics.ARCADE);\n\n    // Make player collide with world boundaries so he doesn't leave the stage\n    this.player.body.collideWorldBounds = true;\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n\n    // Create some ground for the player to walk on\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Collide the player with the ground\n    this.game.physics.arcade.collide(this.player, this.ground);\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, set the player velocity to move left\n        this.player.body.velocity.x = -this.MAX_SPEED;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, set the player velocity to move right\n        this.player.body.velocity.x = this.MAX_SPEED;\n    } else {\n        // Stop the player from moving horizontally\n        this.player.body.velocity.x = 0;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\nvar gam"
                },
                "double_jump": {
                    "notes": "Use the arrow keys or tap to move the player left and right. Press the up arrow or tap the center to jump.\n\nWhile in the air, press the up arrow to jump again.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.image('player', '/assets/gfx/player.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Define movement constants\n    this.MAX_SPEED = 500; // pixels/second\n    this.ACCELERATION = 1500; // pixels/second/second\n    this.DRAG = 600; // pixels/second\n    this.GRAVITY = 2600; // pixels/second/second\n    this.JUMP_SPEED = -1000; // pixels/second (negative y is up)\n\n    // Create a player sprite\n    this.player = this.game.add.sprite(this.game.width/2, this.game.height - 64, 'player');\n\n    // Enable physics on the player\n    this.game.physics.enable(this.player, Phaser.Physics.ARCADE);\n\n    // Make player collide with world boundaries so he doesn't leave the stage\n    this.player.body.collideWorldBounds = true;\n\n    // Set player minimum and maximum movement speed\n    this.player.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED * 10); // x, y\n\n    // Add drag to the player that slows them down when they are not accelerating\n    this.player.body.drag.setTo(this.DRAG, 0); // x, y\n\n    // Since we're jumping we need gravity\n    game.physics.arcade.gravity.y = this.GRAVITY;\n\n    // Flag to track if the jump button is pressed\n    this.jumping = false;\n\n    // Create some ground for the player to walk on\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n\n    // Just for fun, draw some height markers so we can see how high we're jumping\n    this.drawHeightMarkers();\n};\n\n// This function draws horizontal lines across the stage\nGameState.prototype.drawHeightMarkers = function() {\n    // Create a bitmap the same size as the stage\n    var bitmap = this.game.add.bitmapData(this.game.width, this.game.height);\n\n    // These functions use the canvas context to draw lines using the canvas API\n    for(y = this.game.height-32; y >= 64; y -= 32) {\n        bitmap.context.beginPath();\n        bitmap.context.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n        bitmap.context.moveTo(0, y);\n        bitmap.context.lineTo(this.game.width, y);\n        bitmap.context.stroke();\n    }\n\n    this.game.add.image(0, 0, bitmap);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Collide the player with the ground\n    this.game.physics.arcade.collide(this.player, this.ground);\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, set the player velocity to move left\n        this.player.body.acceleration.x = -this.ACCELERATION;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, set the player velocity to move right\n        this.player.body.acceleration.x = this.ACCELERATION;\n    } else {\n        this.player.body.acceleration.x = 0;\n    }\n\n    // Set a variable that is true when the player is touching the ground\n    var onTheGround = this.player.body.touching.down;\n\n    // If the player is touching the ground, let him have 2 jumps\n    if (onTheGround) {\n        this.jumps = 2;\n        this.jumping = false;\n    }\n\n    // Jump!\n    if (this.jumps > 0 && this.upInputIsActive(5)) {\n        this.player.body.velocity.y = this.JUMP_SPEED;\n        this.jumping = true;\n    }\n\n    // Reduce the number of available jumps if the jump input is released\n    if (this.jumping && this.upInputReleased()) {\n        this.jumps--;\n        this.jumping = false;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"jump\" control\n// In this case, either holding the up arrow or tapping or clicking on the center\n// part of the screen.\nGameState.prototype.upInputIsActive = function(duration) {\n    var isActive = false;\n\n    isActive = this.input.keyboard.downDuration(Phaser.Keyboard.UP, duration);\n    isActive |= (this.game.input.activePointer.justPressed(duration + 1000/60) &&\n        this.game.input.activePointer.x > this.game.width/4 &&\n        this.game.input.activePointer.x < this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\n// This function returns true when the player releases the \"jump\" control\nGameState.prototype.upInputReleased = function() {\n    var released = false;\n\n    released = this.input.keyboard.upDuration(Phaser.Keyboard.UP);\n    released |= this.game.input.activePointer.justReleased();\n\n    return released;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                }
            },
            "assets": [
                "/assets/gfx/player.png",
                "/assets/gfx/ground.png"
            ]
        },
        "fluid_simulation": {
            "examples": {
                "fountain": {
                    "notes": "A simple fluid simulation created using physics bodies and WebGL shaders. Move the mouse (or your finger) through the fluid to interact with it. Click or tap to show the physics objects that are behind the simulation. The liquid is faked by using physics particles to provide a base texture and shaders to modify that texture to look like a liquid.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2015 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.image('ball', '/assets/gfx/ball.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Flag to show or hide the droplets making up the fluid\n    this.debug = false;\n\n    // Start the physics system\n    this.game.physics.startSystem(Phaser.Physics.P2JS);\n\n    // Add bounciness and gravity\n    this.game.physics.p2.restitution = 0.8;\n    this.game.physics.p2.gravity.y = 500;\n\n    // Create a new droplet every 50ms\n    this.fluid = this.game.add.group();\n    var t = this.game.time.create();\n    t.loop(50, this.addFluid, this);\n    t.start();\n\n    // Add WebGL shaders to \"liquify\" the droplets\n    this.addShaders();\n\n    // Check tap events\n    this.game.input.onTap.add(this.tap, this);\n};\n\n// Add a single droplet with an initial velocity upwards to simulate a\n// fountain.\nGameState.prototype.addFluid = function() {\n    var randomX = this.game.width/2;\n    var randomY = this.game.height * 0.8;\n\n    // Try to recycle a dead droplet from the fluid group first\n    var droplet = this.fluid.getFirstDead();\n\n    if (droplet) {\n        // A recycled droplet was available, so reset it\n        droplet.reset(randomX, randomY);\n    } else {\n        // No recycled droplets were available so make a new one\n        droplet = this.game.add.sprite(randomX, randomY, 'ball');\n\n        // Enable physics for the droplet\n        this.game.physics.p2.enable(droplet);\n        droplet.body.collideWorldBounds = true;\n\n        // This makes the collision body smaller so that the droplets can get\n        // really up close and goopy\n        droplet.body.setCircle(droplet.width * 0.3);\n\n        // Add a force that slows down the droplet over time\n        droplet.body.damping = 0.3;\n\n        // Add the droplet to the fluid group\n        this.fluid.add(droplet);\n    }\n\n    // Show/hide the physics body\n    droplet.body.debug = this.debug;\n\n    // Initial velocity\n    droplet.body.velocity.y = -600;\n    droplet.body.velocity.x = this.game.rnd.between(-20, 20);\n};\n\n// Add fragment shaders to make the droplets look like a fluid.\nGameState.prototype.addShaders = function() {\n    var blurShader = this.game.add.filter('Blur');\n    blurShader.blur = 32;\n    var threshShader = this.game.add.filter('Threshold');\n    this.fluid.filters = [ blurShader, threshShader ];\n    this.fluid.filterArea = this.game.camera.view;\n};\n\n// Show/hide physics bodies when the screen is clicked/tapped\nGameState.prototype.tap = function() {\n    this.debug = !this.debug;\n    this.fluid.setAll('body.debug', this.debug);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Move droplets away from the pointer\n    if (this.game.input.activePointer.withinGame) {\n        this.fluid.forEachAlive(function(droplet) {\n            var pointer = this.game.input.activePointer;\n            var angle = Math.atan2(pointer.y - droplet.y, pointer.x - droplet.x);\n            var distance = Phaser.Point.distance(pointer, droplet);\n            if (distance < 80) {\n                droplet.body.velocity.x = -Math.cos(angle) * 200;\n                droplet.body.velocity.y = -Math.sin(angle) * 200;\n            }\n        }, this);\n    }\n\n    // Remove water that hits the ground\n    this.fluid.forEachAlive(function(droplet) {\n        if (droplet.y > this.game.height - 15) droplet.kill();\n    }, this);\n};\n\n// Fragment shaders are small programs that run on the graphics card and alter\n// the pixels of a texture. Every framework implements shaders differently but\n// the concept is the same. These shaders take the fluid texture and alters\n// the pixels so that it appears to be a liquid. Shader programming itself is\n// beyond the scope of this tutorial.\n//\n// There are a ton of good resources out there to learn it. Odds are that your\n// framework already includes many of the most popular shaders out of the box.\n//\n// This is an OpenGL/WebGL feature. Because it runs in your web browser you\n// need a browser that support WebGL for this to work.\nPhaser.Filter.Threshold = function(game) {\n    Phaser.Filter.call(this, game);\n\n    this.fragmentSrc = [\n      \"precision mediump float;\",\n      \"varying vec2 vTextureCoord;\",\n      \"varying vec4 vColor;\",\n      \"uniform sampler2D uSampler;\",\n\n      \"void main(void) {\",\n        \"vec4 color = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));\",\n        \"float thresh = step(0.3, color.a);\",\n        \"vec4 sum = vec4(thresh * 0.7, thresh * 0.9, thresh, thresh);\",\n        \"gl_FragColor = sum;\",\n\n      \"}\"\n    ];\n\n};\n\nPhaser.Filter.Threshold.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.Threshold.prototype.constructor = Phaser.Filter.Threshold;\n\nPhaser.Filter.BlurX = function(game) {\n    Phaser.Filter.call(this, game);\n\n    this.uniforms.blur = { type: '1f', value: 1 / 512 };\n\n    this.fragmentSrc = [\n      \"precision mediump float;\",\n      \"varying vec2 vTextureCoord;\",\n      \"varying vec4 vColor;\",\n      \"uniform float blur;\",\n      \"uniform sampler2D uSampler;\",\n\n      \"void main(void) {\",\n        \"vec4 sum = vec4(0.0);\",\n\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;\",\n\n        \"gl_FragColor = sum;\",\n\n      \"}\"\n    ];\n\n};\n\nPhaser.Filter.BlurX.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.BlurX.prototype.constructor = Phaser.Filter.BlurX;\n\nObject.defineProperty(Phaser.Filter.BlurX.prototype, 'blur', {\n\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n\n    set: function(value) {\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n\n});\n\nPhaser.Filter.BlurY = function(game) {\n    Phaser.Filter.call(this, game);\n\n    this.uniforms.blur = { type: '1f', value: 1 / 512 };\n\n    this.fragmentSrc = [\n      \"precision mediump float;\",\n      \"varying vec2 vTextureCoord;\",\n      \"varying vec4 vColor;\",\n      \"uniform float blur;\",\n      \"uniform sampler2D uSampler;\",\n\n      \"void main(void) {\",\n        \"vec4 sum = vec4(0.0);\",\n\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;\",\n\n        \"gl_FragColor = sum;\",\n\n      \"}\"\n    ];\n\n};\n\nPhaser.Filter.BlurY.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.BlurY.prototype.constructor = Phaser.Filter.BlurY;\n\nObject.defineProperty(Phaser.Filter.BlurY.prototype, 'blur', {\n\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n\n    set: function(value) {\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n\n});\n\nPhaser.Filter.Blur = function(game) {\n    this.blurXFilter = new Phaser.Filter.BlurX();\n    this.blurYFilter = new Phaser.Filter.BlurY();\n\n    this.passes = [this.blurXFilter, this.blurYFilter];\n};\n\nPhaser.Filter.Blur.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.Blur.prototype.constructor = Phaser.Filter.Blur;\n\nObject.defineProperty(Phaser.Filter.Blur.prototype, 'blur', {\n    get: function() {\n        return this.blurXFilter.blur;\n    },\n    set: function(value) {\n        this.blurXFilter.blur = this.blurYFilter.blur = value;\n    }\n});\n\nObject.defineProperty(Phaser.Filter.Blur.prototype, 'padding', {\n    get: function() {\n        return this.blurXFilter.padding;\n    },\n    set: function(value) {\n        this.blurXFilter.padding = this.blurYFilter.padding = value;\n    }\n});\n\n// Setup game\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "with_gravity": {
                    "notes": "A simple fluid simulation created using physics bodies and WebGL shaders. Move the mouse (or your finger) through the fluid to interact with it. Click or tap to show the physics objects that are behind the simulation. The liquid is faked by using physics particles to provide a base texture and shaders to modify that texture to look like a liquid.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2015 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.image('ball', '/assets/gfx/ball.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Flag to show or hide the droplets making up the fluid\n    this.debug = false;\n\n    // Start the physics system\n    this.game.physics.startSystem(Phaser.Physics.P2JS);\n\n    // Add bounciness and gravity\n    this.game.physics.p2.restitution = 0.8;\n    this.game.physics.p2.gravity.y = 250;\n\n    // Create fluid droplets\n    this.fluid = this.game.add.group();\n    for (var i = 0; i < 400; i++) {\n        var randomX = game.rnd.between(0, this.game.width);\n        var randomY = game.rnd.between(0, this.game.height);\n        \n        var droplet = this.game.add.sprite(randomX, randomY, 'ball');\n\n        // Enable physics for the droplet\n        this.game.physics.p2.enable(droplet);\n        droplet.body.collideWorldBounds = true;\n\n        // Add a force that slows down the droplet over time\n        droplet.body.damping = 0.3;\n\n        // This makes the collision body smaller so that the droplets can get\n        // really up close and goopy\n        droplet.body.setCircle(droplet.width * 0.3);\n\n        // Add the droplet to the fluid group\n        this.fluid.add(droplet);\n    }\n\n    // Add WebGL shaders to \"liquify\" the droplets\n    this.addShaders();\n\n    // Check tap events\n    this.game.input.onTap.add(this.tap, this);\n};\n\n// Add fragment shaders to make the droplets look like a fluid.\nGameState.prototype.addShaders = function() {\n    var blurShader = this.game.add.filter('Blur');\n    blurShader.blur = 32;\n    var threshShader = this.game.add.filter('Threshold');\n    this.fluid.filters = [ blurShader, threshShader ];\n    this.fluid.filterArea = this.game.camera.view;\n};\n\n// Show/hide physics bodies when the screen is clicked/tapped\nGameState.prototype.tap = function() {\n    this.debug = !this.debug;\n    this.fluid.setAll('body.debug', this.debug);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Move droplets away from the pointer\n    if (this.game.input.activePointer.withinGame) {\n        this.fluid.forEachAlive(function(droplet) {\n            var pointer = this.game.input.activePointer;\n            var angle = Math.atan2(pointer.y - droplet.y, pointer.x - droplet.x);\n            var distance = Phaser.Point.distance(pointer, droplet);\n            if (distance < 80) {\n                droplet.body.velocity.x = -Math.cos(angle) * 200;\n                droplet.body.velocity.y = -Math.sin(angle) * 200;\n            }\n        }, this);\n    }\n};\n\n// Fragment shaders are small programs that run on the graphics card and alter\n// the pixels of a texture. Every framework implements shaders differently but\n// the concept is the same. These shaders take the fluid texture and alters\n// the pixels so that it appears to be a liquid. Shader programming itself is\n// beyond the scope of this tutorial.\n//\n// There are a ton of good resources out there to learn it. Odds are that your\n// framework already includes many of the most popular shaders out of the box.\n//\n// This is an OpenGL/WebGL feature. Because it runs in your web browser you\n// need a browser that support WebGL for this to work.\nPhaser.Filter.Threshold = function(game) {\n    Phaser.Filter.call(this, game);\n\n    this.fragmentSrc = [\n      \"precision mediump float;\",\n      \"varying vec2 vTextureCoord;\",\n      \"varying vec4 vColor;\",\n      \"uniform sampler2D uSampler;\",\n\n      \"void main(void) {\",\n        \"vec4 color = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));\",\n        \"float thresh = step(0.3, color.a);\",\n        \"vec4 sum = vec4(thresh * 0.7, thresh * 0.9, thresh, thresh);\",\n        \"gl_FragColor = sum;\",\n\n      \"}\"\n    ];\n\n};\n\nPhaser.Filter.Threshold.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.Threshold.prototype.constructor = Phaser.Filter.Threshold;\n\nPhaser.Filter.BlurX = function(game) {\n    Phaser.Filter.call(this, game);\n\n    this.uniforms.blur = { type: '1f', value: 1 / 512 };\n\n    this.fragmentSrc = [\n      \"precision mediump float;\",\n      \"varying vec2 vTextureCoord;\",\n      \"varying vec4 vColor;\",\n      \"uniform float blur;\",\n      \"uniform sampler2D uSampler;\",\n\n      \"void main(void) {\",\n        \"vec4 sum = vec4(0.0);\",\n\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;\",\n\n        \"gl_FragColor = sum;\",\n\n      \"}\"\n    ];\n\n};\n\nPhaser.Filter.BlurX.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.BlurX.prototype.constructor = Phaser.Filter.BlurX;\n\nObject.defineProperty(Phaser.Filter.BlurX.prototype, 'blur', {\n\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n\n    set: function(value) {\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n\n});\n\nPhaser.Filter.BlurY = function(game) {\n    Phaser.Filter.call(this, game);\n\n    this.uniforms.blur = { type: '1f', value: 1 / 512 };\n\n    this.fragmentSrc = [\n      \"precision mediump float;\",\n      \"varying vec2 vTextureCoord;\",\n      \"varying vec4 vColor;\",\n      \"uniform float blur;\",\n      \"uniform sampler2D uSampler;\",\n\n      \"void main(void) {\",\n        \"vec4 sum = vec4(0.0);\",\n\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;\",\n\n        \"gl_FragColor = sum;\",\n\n      \"}\"\n    ];\n\n};\n\nPhaser.Filter.BlurY.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.BlurY.prototype.constructor = Phaser.Filter.BlurY;\n\nObject.defineProperty(Phaser.Filter.BlurY.prototype, 'blur', {\n\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n\n    set: function(value) {\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n\n});\n\nPhaser.Filter.Blur = function(game) {\n    this.blurXFilter = new Phaser.Filter.BlurX();\n    this.blurYFilter = new Phaser.Filter.BlurY();\n\n    this.passes = [this.blurXFilter, this.blurYFilter];\n};\n\nPhaser.Filter.Blur.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.Blur.prototype.constructor = Phaser.Filter.Blur;\n\nObject.defineProperty(Phaser.Filter.Blur.prototype, 'blur', {\n    get: function() {\n        return this.blurXFilter.blur;\n    },\n    set: function(value) {\n        this.blurXFilter.blur = this.blurYFilter.blur = value;\n    }\n});\n\nObject.defineProperty(Phaser.Filter.Blur.prototype, 'padding', {\n    get: function() {\n        return this.blurXFilter.padding;\n    },\n    set: function(value) {\n        this.blurXFilter.padding = this.blurYFilter.padding = value;\n    }\n});\n\n// Setup game\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "no_gravity": {
                    "notes": "A simple fluid simulation created using physics bodies and WebGL shaders. Move the mouse (or your finger) through the fluid to interact with it. Click or tap to show the physics objects that are behind the simulation. The liquid is faked by using physics particles to provide a base texture and shaders to modify that texture to look like a liquid.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2015 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.image('ball', '/assets/gfx/ball.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Flag to show or hide the droplets making up the fluid\n    this.debug = false;\n\n    // Start the physics system\n    this.game.physics.startSystem(Phaser.Physics.P2JS);\n\n    // Add bounciness\n    this.game.physics.p2.restitution = 0.8;\n\n    // Create fluid droplets\n    this.fluid = this.game.add.group();\n    for (var i = 0; i < 400; i++) {\n        var randomX = game.rnd.between(0, this.game.width);\n        var randomY = game.rnd.between(0, this.game.height);\n        \n        var droplet = this.game.add.sprite(randomX, randomY, 'ball');\n\n        // Enable physics for the droplet\n        this.game.physics.p2.enable(droplet);\n        droplet.body.collideWorldBounds = true;\n\n        // Add a force that slows down the droplet over time\n        droplet.body.damping = 0.3;\n\n        // This makes the collision body smaller so that the droplets can get\n        // really up close and goopy\n        droplet.body.setCircle(droplet.width * 0.3);\n\n        // Add the droplet to the fluid group\n        this.fluid.add(droplet);\n    }\n\n    // Add WebGL shaders to \"liquify\" the droplets\n    this.addShaders();\n\n    // Check tap events\n    this.game.input.onTap.add(this.tap, this);\n};\n\n// Add fragment shaders to make the droplets look like a fluid.\nGameState.prototype.addShaders = function() {\n    var blurShader = this.game.add.filter('Blur');\n    blurShader.blur = 32;\n    var threshShader = this.game.add.filter('Threshold');\n    this.fluid.filters = [ blurShader, threshShader ];\n    this.fluid.filterArea = this.game.camera.view;\n};\n\n// Show/hide physics bodies when the screen is clicked/tapped\nGameState.prototype.tap = function() {\n    this.debug = !this.debug;\n    this.fluid.setAll('body.debug', this.debug);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Move droplets away from the pointer\n    if (this.game.input.activePointer.withinGame) {\n        this.fluid.forEachAlive(function(droplet) {\n            var pointer = this.game.input.activePointer;\n            var angle = Math.atan2(pointer.y - droplet.y, pointer.x - droplet.x);\n            var distance = Phaser.Point.distance(pointer, droplet);\n            if (distance < 80) {\n                droplet.body.velocity.x = -Math.cos(angle) * 200;\n                droplet.body.velocity.y = -Math.sin(angle) * 200;\n            }\n        }, this);\n    }\n};\n\n// Fragment shaders are small programs that run on the graphics card and alter\n// the pixels of a texture. Every framework implements shaders differently but\n// the concept is the same. These shaders take the fluid texture and alters\n// the pixels so that it appears to be a liquid. Shader programming itself is\n// beyond the scope of this tutorial.\n//\n// There are a ton of good resources out there to learn it. Odds are that your\n// framework already includes many of the most popular shaders out of the box.\n//\n// This is an OpenGL/WebGL feature. Because it runs in your web browser you\n// need a browser that support WebGL for this to work.\nPhaser.Filter.Threshold = function(game) {\n    Phaser.Filter.call(this, game);\n\n    this.fragmentSrc = [\n      \"precision mediump float;\",\n      \"varying vec2 vTextureCoord;\",\n      \"varying vec4 vColor;\",\n      \"uniform sampler2D uSampler;\",\n\n      \"void main(void) {\",\n        \"vec4 color = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));\",\n        \"float thresh = step(0.3, color.a);\",\n        \"vec4 sum = vec4(thresh * 0.7, thresh * 0.9, thresh, thresh);\",\n        \"gl_FragColor = sum;\",\n\n      \"}\"\n    ];\n\n};\n\nPhaser.Filter.Threshold.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.Threshold.prototype.constructor = Phaser.Filter.Threshold;\n\nPhaser.Filter.BlurX = function(game) {\n    Phaser.Filter.call(this, game);\n\n    this.uniforms.blur = { type: '1f', value: 1 / 512 };\n\n    this.fragmentSrc = [\n      \"precision mediump float;\",\n      \"varying vec2 vTextureCoord;\",\n      \"varying vec4 vColor;\",\n      \"uniform float blur;\",\n      \"uniform sampler2D uSampler;\",\n\n      \"void main(void) {\",\n        \"vec4 sum = vec4(0.0);\",\n\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;\",\n\n        \"gl_FragColor = sum;\",\n\n      \"}\"\n    ];\n\n};\n\nPhaser.Filter.BlurX.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.BlurX.prototype.constructor = Phaser.Filter.BlurX;\n\nObject.defineProperty(Phaser.Filter.BlurX.prototype, 'blur', {\n\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n\n    set: function(value) {\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n\n});\n\nPhaser.Filter.BlurY = function(game) {\n    Phaser.Filter.call(this, game);\n\n    this.uniforms.blur = { type: '1f', value: 1 / 512 };\n\n    this.fragmentSrc = [\n      \"precision mediump float;\",\n      \"varying vec2 vTextureCoord;\",\n      \"varying vec4 vColor;\",\n      \"uniform float blur;\",\n      \"uniform sampler2D uSampler;\",\n\n      \"void main(void) {\",\n        \"vec4 sum = vec4(0.0);\",\n\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;\",\n        \"sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;\",\n\n        \"gl_FragColor = sum;\",\n\n      \"}\"\n    ];\n\n};\n\nPhaser.Filter.BlurY.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.BlurY.prototype.constructor = Phaser.Filter.BlurY;\n\nObject.defineProperty(Phaser.Filter.BlurY.prototype, 'blur', {\n\n    get: function() {\n        return this.uniforms.blur.value / (1/7000);\n    },\n\n    set: function(value) {\n        this.uniforms.blur.value = (1/7000) * value;\n    }\n\n});\n\nPhaser.Filter.Blur = function(game) {\n    this.blurXFilter = new Phaser.Filter.BlurX();\n    this.blurYFilter = new Phaser.Filter.BlurY();\n\n    this.passes = [this.blurXFilter, this.blurYFilter];\n};\n\nPhaser.Filter.Blur.prototype = Object.create(Phaser.Filter.prototype);\nPhaser.Filter.Blur.prototype.constructor = Phaser.Filter.Blur;\n\nObject.defineProperty(Phaser.Filter.Blur.prototype, 'blur', {\n    get: function() {\n        return this.blurXFilter.blur;\n    },\n    set: function(value) {\n        this.blurXFilter.blur = this.blurYFilter.blur = value;\n    }\n});\n\nObject.defineProperty(Phaser.Filter.Blur.prototype, 'padding', {\n    get: function() {\n        return this.blurXFilter.padding;\n    },\n    set: function(value) {\n        this.blurXFilter.padding = this.blurYFilter.padding = value;\n    }\n});\n\n// Setup game\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                }
            },
            "assets": [
                "/assets/gfx/ball.png",
                "/assets/gfx/ground.png"
            ]
        },
        "spaceship_motion": {
            "examples": {
                "basic_movement": {
                    "notes": "Use the left and right arrow keys or tap near the edges to rotate the ship. Press the up arrow key or tap the center to turn on the engine.\n\nThis is an example of Asteroids-style motion. The ship moves in straight lines until the engine is turned on and accelerates. When the ship reaches any of the stage boundaries it is repositioned to the opposite side. The ship rotates at ROTATION_SPEED degrees/second.\n\n",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.spritesheet('ship', '/assets/gfx/ship.png', 32, 32);\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x333333;\n\n    // Define motion constants\n    this.ROTATION_SPEED = 180; // degrees/second\n    this.ACCELERATION = 200; // pixels/second/second\n    this.MAX_SPEED = 250; // pixels/second\n\n    // Add the ship to the stage\n    this.ship = this.game.add.sprite(this.game.width/2, this.game.height/2, 'ship');\n    this.ship.anchor.setTo(0.5, 0.5);\n    this.ship.angle = -90; // Point the ship up\n\n    // Enable physics on the ship\n    this.game.physics.enable(this.ship, Phaser.Physics.ARCADE);\n\n    // Set maximum velocity\n    this.ship.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED); // x, y\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Keep the ship on the screen\n    if (this.ship.x > this.game.width) this.ship.x = 0;\n    if (this.ship.x < 0) this.ship.x = this.game.width;\n    if (this.ship.y > this.game.height) this.ship.y = 0;\n    if (this.ship.y < 0) this.ship.y = this.game.height;\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, rotate left\n        this.ship.body.angularVelocity = -this.ROTATION_SPEED;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, rotate right\n        this.ship.body.angularVelocity = this.ROTATION_SPEED;\n    } else {\n        // Stop rotating\n        this.ship.body.angularVelocity = 0;\n    }\n\n    if (this.upInputIsActive()) {\n        // If the UP key is down, thrust\n        // Calculate acceleration vector based on this.angle and this.ACCELERATION\n        this.ship.body.acceleration.x = Math.cos(this.ship.rotation) * this.ACCELERATION;\n        this.ship.body.acceleration.y = Math.sin(this.ship.rotation) * this.ACCELERATION;\n\n        // Show the frame from the spritesheet with the engine on\n        this.ship.frame = 1;\n    } else {\n        // Otherwise, stop thrusting\n        this.ship.body.acceleration.setTo(0, 0);\n\n        // Show the frame from the spritesheet with the engine off\n        this.ship.frame = 0;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"jump\" control\n// In this case, either holding the up arrow or tapping or clicking on the center\n// part of the screen.\nGameState.prototype.upInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.UP);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/4 &&\n        this.game.input.activePointer.x < this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "with_drag": {
                    "notes": "Use the left and right arrow keys or tap near the edges to rotate the ship. Press the up arrow key or tap the center to turn on the engine.\n\nThe ship now has a DRAG component. DRAG works by applying a velocity in the opposite direction of the ship movement whenever the ship is not accelerating. This causes the ship to slow down gradually when the engine is off.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.spritesheet('ship', '/assets/gfx/ship.png', 32, 32);\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x333333;\n\n    // Define motion constants\n    this.ROTATION_SPEED = 180; // degrees/second\n    this.ACCELERATION = 200; // pixels/second/second\n    this.MAX_SPEED = 250; // pixels/second\n    this.DRAG = 50; // pixels/second\n\n    // Add the ship to the stage\n    this.ship = this.game.add.sprite(this.game.width/2, this.game.height/2, 'ship');\n    this.ship.anchor.setTo(0.5, 0.5);\n    this.ship.angle = -90; // Point the ship up\n\n    // Enable physics on the ship\n    this.game.physics.enable(this.ship, Phaser.Physics.ARCADE);\n\n    // Set maximum velocity\n    this.ship.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED); // x, y\n\n    // Add drag to the ship that slows it down when it is not accelerating\n    this.ship.body.drag.setTo(this.DRAG, this.DRAG); // x, y\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Keep the ship on the screen\n    if (this.ship.x > this.game.width) this.ship.x = 0;\n    if (this.ship.x < 0) this.ship.x = this.game.width;\n    if (this.ship.y > this.game.height) this.ship.y = 0;\n    if (this.ship.y < 0) this.ship.y = this.game.height;\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, rotate left\n        this.ship.body.angularVelocity = -this.ROTATION_SPEED;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, rotate right\n        this.ship.body.angularVelocity = this.ROTATION_SPEED;\n    } else {\n        // Stop rotating\n        this.ship.body.angularVelocity = 0;\n    }\n\n    if (this.upInputIsActive()) {\n        // If the UP key is down, thrust\n        // Calculate acceleration vector based on this.angle and this.ACCELERATION\n        this.ship.body.acceleration.x = Math.cos(this.ship.rotation) * this.ACCELERATION;\n        this.ship.body.acceleration.y = Math.sin(this.ship.rotation) * this.ACCELERATION;\n\n        // Show the frame from the spritesheet with the engine on\n        this.ship.frame = 1;\n    } else {\n        // Otherwise, stop thrusting\n        this.ship.body.acceleration.setTo(0, 0);\n\n        // Show the frame from the spritesheet with the engine off\n        this.ship.frame = 0;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"jump\" control\n// In this case, either holding the up arrow or tapping or clicking on the center\n// part of the screen.\nGameState.prototype.upInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.UP);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/4 &&\n        this.game.input.activePointer.x < this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "lunar_lander": {
                    "notes": "Use the left and right arrow keys or tap near the edges to rotate the ship. Press the up arrow key or tap the center to turn on the engine.\n\nTry to land the ship safely on the ground. You must land gently or the ship will explode!\n\nThis example introduces a function getExplosion() which either creates a new explosion object or re-uses one that was created earlier. This approach allows the number of explosion sprites to increase dynamically but never creates more than are needed to display on screen at any one time.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.spritesheet('ship', '/assets/gfx/ship.png', 32, 32);\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n    this.game.load.spritesheet('explosion', '/assets/gfx/explosion.png', 128, 128);\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x333333;\n\n    // Define motion constants\n    this.ROTATION_SPEED = 180; // degrees/second\n    this.ACCELERATION = 200; // pixels/second/second\n    this.MAX_SPEED = 250; // pixels/second\n    this.DRAG = 0; // pixels/second\n    this.GRAVITY = 50; // pixels/second/second\n\n    // Add the ship to the stage\n    this.ship = this.game.add.sprite(0, 0, 'ship');\n    this.ship.anchor.setTo(0.5, 0.5);\n    this.ship.angle = -90; // Point the ship up\n\n    // Enable physics on the ship\n    this.game.physics.enable(this.ship, Phaser.Physics.ARCADE);\n\n    // Set maximum velocity\n    this.ship.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED); // x, y\n\n    // Add drag to the ship that slows it down when it is not accelerating\n    this.ship.body.drag.setTo(this.DRAG, this.DRAG); // x, y\n\n    // Choose a random starting angle and velocity for the ship\n    this.resetShip();\n\n    // Turn on gravity\n    game.physics.arcade.gravity.y = this.GRAVITY;\n\n    // Make ship bounce a little\n    this.ship.body.bounce.setTo(0.25, 0.25);\n\n    // Create some ground for the ship to land on\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n\n    // Create a group for explosions\n    this.explosionGroup = this.game.add.group();\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n};\n\n// Try to get a used explosion from the explosionGroup.\n// If an explosion isn't available, create a new one and add it to the group.\n// Setup new explosions so that they animate and kill themselves when the\n// animation is complete.\nGameState.prototype.getExplosion = function(x, y) {\n    // Get the first dead explosion from the explosionGroup\n    var explosion = this.explosionGroup.getFirstDead();\n\n    // If there aren't any available, create a new one\n    if (explosion === null) {\n        explosion = this.game.add.sprite(0, 0, 'explosion');\n        explosion.anchor.setTo(0.5, 0.5);\n\n        // Add an animation for the explosion that kills the sprite when the\n        // animation is complete\n        var animation = explosion.animations.add('boom', [0,1,2,3], 60, false);\n        animation.killOnComplete = true;\n\n        // Add the explosion sprite to the group\n        this.explosionGroup.add(explosion);\n    }\n\n    // Revive the explosion (set it's alive property to true)\n    // You can also define a onRevived event handler in your explosion objects\n    // to do stuff when they are revived.\n    explosion.revive();\n\n    // Move the explosion to the given coordinates\n    explosion.x = x;\n    explosion.y = y;\n\n    // Set rotation of the explosion at random for a little variety\n    explosion.angle = this.game.rnd.integerInRange(0, 360);\n\n    // Play the animation\n    explosion.animations.play('boom');\n\n    // Return the explosion itself in case we want to do anything else with it\n    return explosion;\n};\n\nGameState.prototype.resetShip = function() {\n    // Move the ship back to the top of the stage\n    this.ship.x = 32;\n    this.ship.y = 32;\n    this.ship.body.acceleration.setTo(0, 0);\n\n    // Select a random starting angle and velocity\n    this.ship.angle = this.game.rnd.integerInRange(-180, 180);\n    this.ship.body.velocity.setTo(this.game.rnd.integerInRange(100, 200), 0);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Collide the ship with the ground\n    this.game.physics.arcade.collide(this.ship, this.ground);\n\n    // Keep the ship on the screen\n    if (this.ship.x > this.game.width) this.ship.x = 0;\n    if (this.ship.x < 0) this.ship.x = this.game.width;\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, rotate left\n        this.ship.body.angularVelocity = -this.ROTATION_SPEED;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, rotate right\n        this.ship.body.angularVelocity = this.ROTATION_SPEED;\n    } else {\n        // Stop rotating\n        this.ship.body.angularVelocity = 0;\n    }\n\n    // Set a variable that is true when the ship is touching the ground\n    var onTheGround = this.ship.body.touching.down;\n\n    if (onTheGround) {\n        if (Math.abs(this.ship.body.velocity.y) > 20 || Math.abs(this.ship.body.velocity.x) > 30) {\n            // The ship hit the ground too hard.\n            // Blow it up and start the game over.\n            this.getExplosion(this.ship.x, this.ship.y);\n            this.resetShip();\n        } else {\n            // We've landed!\n            // Stop rotating and moving and aim the ship up.\n            this.ship.body.angularVelocity = 0;\n            this.ship.body.velocity.setTo(0, 0);\n            this.ship.angle = -90;\n        }\n\n    }\n\n    if (this.upInputIsActive()) {\n        // If the UP key is down, thrust\n        // Calculate acceleration vector based on this.angle and this.ACCELERATION\n        this.ship.body.acceleration.x = Math.cos(this.ship.rotation) * this.ACCELERATION;\n        this.ship.body.acceleration.y = Math.sin(this.ship.rotation) * this.ACCELERATION;\n\n        // Show the frame from the spritesheet with the engine on\n        this.ship.frame = 1;\n    } else {\n        // Otherwise, stop thrusting\n        this.ship.body.acceleration.setTo(0, 0);\n\n        // Show the frame from the spritesheet with the engine off\n        this.ship.frame = 0;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"jump\" control\n// In this case, either holding the up arrow or tapping or clicking on the center\n// part of the screen.\nGameState.prototype.upInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.UP);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/4 &&\n        this.game.input.activePointer.x < this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "with_gravity": {
                    "notes": "Use the left and right arrow keys or tap near the edges to rotate the ship. Press the up arrow key or tap the center to turn on the engine.\n\nThe world now has gravity and a ground you can land on. The ship's ACCELERATION must be stronger than GRAVITY or it will never be able to move up.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.spritesheet('ship', '/assets/gfx/ship.png', 32, 32);\n    this.game.load.image('ground', '/assets/gfx/ground.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x333333;\n\n    // Define motion constants\n    this.ROTATION_SPEED = 180; // degrees/second\n    this.ACCELERATION = 200; // pixels/second/second\n    this.MAX_SPEED = 250; // pixels/second\n    this.DRAG = 25; // pixels/second\n    this.GRAVITY = 100; // pixels/second/second\n\n    // Add the ship to the stage\n    this.ship = this.game.add.sprite(this.game.width/2, this.game.height/2, 'ship');\n    this.ship.anchor.setTo(0.5, 0.5);\n    this.ship.angle = -90; // Point the ship up\n\n    // Enable physics on the ship\n    this.game.physics.enable(this.ship, Phaser.Physics.ARCADE);\n\n    // Set maximum velocity\n    this.ship.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED); // x, y\n\n    // Add drag to the ship that slows it down when it is not accelerating\n    this.ship.body.drag.setTo(this.DRAG, this.DRAG); // x, y\n\n    // Turn on gravity\n    game.physics.arcade.gravity.y = this.GRAVITY;\n\n    // Make ship bounce a little\n    this.ship.body.bounce.setTo(0.25, 0.25);\n\n    // Create some ground for the ship to land on\n    this.ground = this.game.add.group();\n    for(var x = 0; x < this.game.width; x += 32) {\n        // Add the ground blocks, enable physics on each, make them immovable\n        var groundBlock = this.game.add.sprite(x, this.game.height - 32, 'ground');\n        this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);\n        groundBlock.body.immovable = true;\n        groundBlock.body.allowGravity = false;\n        this.ground.add(groundBlock);\n    }\n\n    // Capture certain keys to prevent their default actions in the browser.\n    // This is only necessary because this is an HTML5 game. Games on other\n    // platforms may not need code like this.\n    this.game.input.keyboard.addKeyCapture([\n        Phaser.Keyboard.LEFT,\n        Phaser.Keyboard.RIGHT,\n        Phaser.Keyboard.UP,\n        Phaser.Keyboard.DOWN\n    ]);\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // Collide the ship with the ground\n    this.game.physics.arcade.collide(this.ship, this.ground);\n\n    // Keep the ship on the screen\n    if (this.ship.x > this.game.width) this.ship.x = 0;\n    if (this.ship.x < 0) this.ship.x = this.game.width;\n\n    if (this.leftInputIsActive()) {\n        // If the LEFT key is down, rotate left\n        this.ship.body.angularVelocity = -this.ROTATION_SPEED;\n    } else if (this.rightInputIsActive()) {\n        // If the RIGHT key is down, rotate right\n        this.ship.body.angularVelocity = this.ROTATION_SPEED;\n    } else {\n        // Stop rotating\n        this.ship.body.angularVelocity = 0;\n    }\n\n    if (this.upInputIsActive()) {\n        // If the UP key is down, thrust\n        // Calculate acceleration vector based on this.angle and this.ACCELERATION\n        this.ship.body.acceleration.x = Math.cos(this.ship.rotation) * this.ACCELERATION;\n        this.ship.body.acceleration.y = Math.sin(this.ship.rotation) * this.ACCELERATION;\n\n        // Show the frame from the spritesheet with the engine on\n        this.ship.frame = 1;\n    } else {\n        // Otherwise, stop thrusting\n        this.ship.body.acceleration.setTo(0, 0);\n\n        // Show the frame from the spritesheet with the engine off\n        this.ship.frame = 0;\n    }\n};\n\n// This function should return true when the player activates the \"go left\" control\n// In this case, either holding the right arrow or tapping or clicking on the left\n// side of the screen.\nGameState.prototype.leftInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x < this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"go right\" control\n// In this case, either holding the right arrow or tapping or clicking on the right\n// side of the screen.\nGameState.prototype.rightInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\n// This function should return true when the player activates the \"jump\" control\n// In this case, either holding the up arrow or tapping or clicking on the center\n// part of the screen.\nGameState.prototype.upInputIsActive = function() {\n    var isActive = false;\n\n    isActive = this.input.keyboard.isDown(Phaser.Keyboard.UP);\n    isActive |= (this.game.input.activePointer.isDown &&\n        this.game.input.activePointer.x > this.game.width/4 &&\n        this.game.input.activePointer.x < this.game.width/2 + this.game.width/4);\n\n    return isActive;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                }
            },
            "assets": [
                "/assets/gfx/ship.png",
                "/assets/gfx/ground.png",
                "/assets/gfx/explosion.png"
            ]
        },
        "following": {
            "examples": {
                "single_follower": {
                    "notes": "The object will follow wherever you point or tap.\n\nThis example defines a Follower that takes a target as one of its parameters. The Follower updates its velocity every frame to move it in the direction of the target. It stops when it is within MIN_DISTANCE.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('player', '/assets/gfx/player.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create a follower\n    this.game.add.existing(\n        new Follower(this.game, this.game.width/2, this.game.height/2, this.game.input)\n    );\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.x = this.game.width/2;\n    this.game.input.y = this.game.height/2;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n};\n\n// Follower constructor\nvar Follower = function(game, x, y, target) {\n    Phaser.Sprite.call(this, game, x, y, 'player');\n\n    // Save the target that this Follower will follow\n    // The target is any object with x and y properties\n    this.target = target;\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on this object\n    this.game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Define constants that affect motion\n    this.MAX_SPEED = 250; // pixels/second\n    this.MIN_DISTANCE = 32; // pixels\n};\n\n// Followers are a type of Phaser.Sprite\nFollower.prototype = Object.create(Phaser.Sprite.prototype);\nFollower.prototype.constructor = Follower;\n\nFollower.prototype.update = function() {\n    // Calculate distance to target\n    var distance = this.game.math.distance(this.x, this.y, this.target.x, this.target.y);\n\n    // If the distance > MIN_DISTANCE then move\n    if (distance > this.MIN_DISTANCE) {\n        // Calculate the angle to the target\n        var rotation = this.game.math.angleBetween(this.x, this.y, this.target.x, this.target.y);\n\n        // Calculate velocity vector based on rotation and this.MAX_SPEED\n        this.body.velocity.x = Math.cos(rotation) * this.MAX_SPEED;\n        this.body.velocity.y = Math.sin(rotation) * this.MAX_SPEED;\n    } else {\n        this.body.velocity.setTo(0, 0);\n    }\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "multiple_followers": {
                    "notes": "The object will follow wherever you point or tap.\n\nThis example uses the same Follower as the last example. The only difference is that each Follower (except the first one) targets the Follower in front of it. The first follower still targets the pointer position.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('player', '/assets/gfx/player.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create 5 followers, each one following the one ahead of it\n    // The first one will follow the mouse pointer\n    var NUMBER_OF_FOLLOWERS = 10;\n    for(var i = 0; i < NUMBER_OF_FOLLOWERS; i++) {\n        var f = this.game.add.existing(\n            new Follower(this.game,\n                this.game.width/2 + i * 32,\n                this.game.height/2,\n                f || this.game.input /* the previous follower or pointer */\n            )\n        );\n    }\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.x = this.game.width/2;\n    this.game.input.y = this.game.height/2;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n};\n\n// Follower constructor\nvar Follower = function(game, x, y, target) {\n    Phaser.Sprite.call(this, game, x, y, 'player');\n\n    // Save the target that this Follower will follow\n    // The target is any object with x and y properties\n    this.target = target;\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on this object\n    this.game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Define constants that affect motion\n    this.MAX_SPEED = 250; // pixels/second\n    this.MIN_DISTANCE = 32; // pixels\n};\n\n// Followers are a type of Phaser.Sprite\nFollower.prototype = Object.create(Phaser.Sprite.prototype);\nFollower.prototype.constructor = Follower;\n\nFollower.prototype.update = function() {\n    // Calculate distance to target\n    var distance = this.game.math.distance(this.x, this.y, this.target.x, this.target.y);\n\n    // If the distance > MIN_DISTANCE then move\n    if (distance > this.MIN_DISTANCE) {\n        // Calculate the angle to the target\n        var rotation = this.game.math.angleBetween(this.x, this.y, this.target.x, this.target.y);\n\n        // Calculate velocity vector based on rotation and this.MAX_SPEED\n        this.body.velocity.x = Math.cos(rotation) * this.MAX_SPEED;\n        this.body.velocity.y = Math.sin(rotation) * this.MAX_SPEED;\n    } else {\n        this.body.velocity.setTo(0, 0);\n    }\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "multiple_groups": {
                    "notes": "The object will follow wherever you point or tap.\n\nBecause all of the following logic is self-contained in the Follower class, you can have as many different Followers or groups of Followers as you need. In this example, a second group of Followers is added that targets a flag moving around the perimeter of the stage.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('player', '/assets/gfx/player.png');\n    this.game.load.image('flag', '/assets/gfx/flag.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create 5 followers, each one following the one ahead of it\n    // The first one will follow the mouse pointer\n    var NUMBER_OF_FOLLOWERS = 10;\n    for(var i = 0; i < NUMBER_OF_FOLLOWERS; i++) {\n        var f = this.game.add.existing(\n            new Follower(this.game,\n                this.game.width/2 + i * 32,\n                this.game.height/2,\n                f || this.game.input /* the previous follower or pointer */\n            )\n        );\n    }\n\n    // Create a target for the second group and\n    // move it around the perimeter of the stage.\n    var flag = this.game.add.sprite(50, 50, 'flag');\n    this.game.add.tween(flag)\n        .to({ x: this.game.width - 50, y: 50 }, 2000, Phaser.Easing.Sinusoidal.InOut)\n        .to({ x: this.game.width - 50, y: this.game.height - 50 },\n            1200, Phaser.Easing.Sinusoidal.InOut)\n        .to({ x: 50, y: this.game.height - 50 }, 2000, Phaser.Easing.Sinusoidal.InOut)\n        .to({ x: 50, y: 50 }, 1200, Phaser.Easing.Sinusoidal.InOut)\n        .start()\n        .loop();\n\n    // Create 5 more followers, each one following the one ahead of it\n    // The first one will follow the target\n    for(i = 0; i < NUMBER_OF_FOLLOWERS; i++) {\n        var f2 = this.game.add.existing(\n            new Follower(this.game,\n                this.game.width/2 + i * 32,\n                this.game.height/2,\n                f2 || flag /* the previous follower or the flag */\n            )\n        );\n    }\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.x = this.game.width/2;\n    this.game.input.y = this.game.height/2;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n};\n\n// Follower constructor\nvar Follower = function(game, x, y, target) {\n    Phaser.Sprite.call(this, game, x, y, 'player');\n\n    // Save the target that this Follower will follow\n    // The target is any object with x and y properties\n    this.target = target;\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on this object\n    this.game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Each Follower will record its position history in\n    // an array of point objects (objects with x,y members)\n    // This will be used to make each Follower follow the\n    // same track as its target\n    this.history = [];\n    this.HISTORY_LENGTH = 5;\n\n    // Define constants that affect motion\n    this.MAX_SPEED = 250; // pixels/second\n    this.MIN_DISTANCE = 32; // pixels\n};\n\n// Followers are a type of Phaser.Sprite\nFollower.prototype = Object.create(Phaser.Sprite.prototype);\nFollower.prototype.constructor = Follower;\n\nFollower.prototype.update = function() {\n    // Get the target x and y position.\n    //\n    // This algorithm will follow targets that may or may not have a position\n    // history.\n    //\n    // The targetMoving flag tells this object when its target is moving\n    // so that it knows when to move and when to stop.\n    var t = {};\n    var targetMoving = false;\n    if (this.target.history !== undefined && this.target.history.length) {\n        // This target has a history so go towards that\n        t = this.target.history[0];\n        if (this.target.body.velocity.x !== 0 ||\n            this.target.body.velocity.y !== 0) targetMoving = true;\n    } else {\n        // This target doesn't have a history defined so just\n        // follow its current x and y position\n        t.x = this.target.x;\n        t.y = this.target.y;\n\n        // Calculate distance to target\n        // If the position is far enough way then consider it \"moving\"\n        // so that we can get this Follower to move.\n        var distance = this.game.math.distance(this.x, this.y, t.x, t.y);\n        if (distance > this.MIN_DISTANCE) targetMoving = true;\n    }\n\n    // If the distance > MIN_DISTANCE then move\n    if (targetMoving) {\n        // Add current position to the end of the history array\n        this.history.push({ x: this.x, y: this.y });\n\n        // If the length of the history array is over a certain size\n        // then remove the oldest (first) element\n        if (this.history.length > this.HISTORY_LENGTH) this.history.shift();\n\n        // Calculate the angle to the target\n        var rotation = this.game.math.angleBetween(this.x, this.y, t.x, t.y);\n\n        // Calculate velocity vector based on rotation and this.MAX_SPEED\n        this.body.velocity.x = Math.cos(rotation) * this.MAX_SPEED;\n        this.body.velocity.y = Math.sin(rotation) * this.MAX_SPEED;\n    } else {\n        this.body.velocity.setTo(0, 0);\n    }\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "identical_paths": {
                    "notes": "The object will follow wherever you point or tap.\n\nIn the Multiple Followers example, you may have noticed that the followers don't move very organically when they cross paths or when making tight turns. They behave sort of like a chain lying on the ground. This example addresses that by recording a path history for each Follower. Each follower will use the history to follow exactly the same path as its target.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('player', '/assets/gfx/player.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background color\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create 5 followers, each one following the one ahead of it\n    // The first one will follow the mouse pointer\n    var NUMBER_OF_FOLLOWERS = 10;\n    for(var i = 0; i < NUMBER_OF_FOLLOWERS; i++) {\n        var f = this.game.add.existing(\n            new Follower(this.game,\n                this.game.width/2 + i * 32,\n                this.game.height/2,\n                f || this.game.input /* the previous follower or pointer */\n            )\n        );\n    }\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.x = this.game.width/2;\n    this.game.input.y = this.game.height/2;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n};\n\n// Follower constructor\nvar Follower = function(game, x, y, target) {\n    Phaser.Sprite.call(this, game, x, y, 'player');\n\n    // Save the target that this Follower will follow\n    // The target is any object with x and y properties\n    this.target = target;\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on this object\n    this.game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Each Follower will record its position history in\n    // an array of point objects (objects with x,y members)\n    // This will be used to make each Follower follow the\n    // same track as its target\n    this.history = [];\n    this.HISTORY_LENGTH = 5;\n\n    // Define constants that affect motion\n    this.MAX_SPEED = 250; // pixels/second\n    this.MIN_DISTANCE = 32; // pixels\n};\n\n// Followers are a type of Phaser.Sprite\nFollower.prototype = Object.create(Phaser.Sprite.prototype);\nFollower.prototype.constructor = Follower;\n\nFollower.prototype.update = function() {\n    // Get the target x and y position.\n    //\n    // This algorithm will follow targets that may or may not have a position\n    // history.\n    //\n    // The targetMoving flag tells this object when its target is moving\n    // so that it knows when to move and when to stop.\n    var t = {};\n    var targetMoving = false;\n    if (this.target.history !== undefined && this.target.history.length) {\n        // This target has a history so go towards that\n        t = this.target.history[0];\n        if (this.target.body.velocity.x !== 0 ||\n            this.target.body.velocity.y !== 0) targetMoving = true;\n    } else {\n        // This target doesn't have a history defined so just\n        // follow its current x and y position\n        t.x = this.target.x;\n        t.y = this.target.y;\n\n        // Calculate distance to target\n        // If the position is far enough way then consider it \"moving\"\n        // so that we can get this Follower to move.\n        var distance = this.game.math.distance(this.x, this.y, t.x, t.y);\n        if (distance > this.MIN_DISTANCE) targetMoving = true;\n    }\n\n    // If the distance > MIN_DISTANCE then move\n    if (targetMoving) {\n        // Add current position to the end of the history array\n        this.history.push({ x: this.x, y: this.y });\n\n        // If the length of the history array is over a certain size\n        // then remove the oldest (first) element\n        if (this.history.length > this.HISTORY_LENGTH) this.history.shift();\n\n        // Calculate the angle to the target\n        var rotation = this.game.math.angleBetween(this.x, this.y, t.x, t.y);\n\n        // Calculate velocity vector based on rotation and this.MAX_SPEED\n        this.body.velocity.x = Math.cos(rotation) * this.MAX_SPEED;\n        this.body.velocity.y = Math.sin(rotation) * this.MAX_SPEED;\n    } else {\n        this.body.velocity.setTo(0, 0);\n    }\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                }
            },
            "assets": [
                "/assets/gfx/flag.png",
                "/assets/gfx/player.png"
            ]
        },
        "homing_missile": {
            "examples": {
                "multiple_missiles": {
                    "notes": "The missiles will target the pointer (or tap). Move the pointer around the example area.\n\nLaunching multiple missiles is as simple as creating a new Missile() since all of the steering control for each missile is self-contained within the missile object itself.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n    this.MAX_MISSILES = 3; // number of missiles\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('rocket', '/assets/gfx/rocket.png');\n    this.game.load.image('smoke', '/assets/gfx/smoke.png');\n\n    this.game.load.spritesheet('explosion', '/assets/gfx/explosion.png', 128, 128);\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create a group to hold the missile\n    this.missileGroup = this.game.add.group();\n\n    // Create a group for explosions\n    this.explosionGroup = this.game.add.group();\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.activePointer.x = this.game.width/2;\n    this.game.input.activePointer.y = this.game.height/2 - 100;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // If there are fewer than MAX_MISSILES, launch a new one\n    if (this.missileGroup.countLiving() < this.MAX_MISSILES) {\n        // Set the launch point to a random location below the bottom edge\n        // of the stage\n        this.launchMissile(this.game.rnd.integerInRange(50, this.game.width-50),\n            this.game.height + 50);\n    }\n\n    // If any missile is within a certain distance of the mouse pointer, blow it up\n    this.missileGroup.forEachAlive(function(m) {\n        var distance = this.game.math.distance(m.x, m.y,\n            this.game.input.activePointer.x, this.game.input.activePointer.y);\n        if (distance < 50) {\n            m.kill();\n            this.getExplosion(m.x, m.y);\n        }\n    }, this);\n};\n\n// Try to get a missile from the missileGroup\n// If a missile isn't available, create a new one and add it to the group.\nGameState.prototype.launchMissile = function(x, y) {\n    // // Get the first dead missile from the missileGroup\n    var missile = this.missileGroup.getFirstDead();\n\n    // If there aren't any available, create a new one\n    if (missile === null) {\n        missile = new Missile(this.game);\n        this.missileGroup.add(missile);\n    }\n\n    // Revive the missile (set it's alive property to true)\n    // You can also define a onRevived event handler in your explosion objects\n    // to do stuff when they are revived.\n    missile.revive();\n\n    // Move the missile to the given coordinates\n    missile.x = x;\n    missile.y = y;\n\n    return missile;\n};\n\n// Try to get a used explosion from the explosionGroup.\n// If an explosion isn't available, create a new one and add it to the group.\n// Setup new explosions so that they animate and kill themselves when the\n// animation is complete.\nGameState.prototype.getExplosion = function(x, y) {\n    // Get the first dead explosion from the explosionGroup\n    var explosion = this.explosionGroup.getFirstDead();\n\n    // If there aren't any available, create a new one\n    if (explosion === null) {\n        explosion = this.game.add.sprite(0, 0, 'explosion');\n        explosion.anchor.setTo(0.5, 0.5);\n\n        // Add an animation for the explosion that kills the sprite when the\n        // animation is complete\n        var animation = explosion.animations.add('boom', [0,1,2,3], 60, false);\n        animation.killOnComplete = true;\n\n        // Add the explosion sprite to the group\n        this.explosionGroup.add(explosion);\n    }\n\n    // Revive the explosion (set it's alive property to true)\n    // You can also define a onRevived event handler in your explosion objects\n    // to do stuff when they are revived.\n    explosion.revive();\n\n    // Move the explosion to the given coordinates\n    explosion.x = x;\n    explosion.y = y;\n\n    // Set rotation of the explosion at random for a little variety\n    explosion.angle = this.game.rnd.integerInRange(0, 360);\n\n    // Play the animation\n    explosion.animations.play('boom');\n\n    // Return the explosion itself in case we want to do anything else with it\n    return explosion;\n};\n\n// Missile constructor\nvar Missile = function(game, x, y) {\n    Phaser.Sprite.call(this, game, x, y, 'rocket');\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on the missile\n    this.game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Define constants that affect motion\n    this.SPEED = 250; // missile speed pixels/second\n    this.TURN_RATE = 5; // turn rate in degrees/frame\n    this.WOBBLE_LIMIT = 15; // degrees\n    this.WOBBLE_SPEED = 250; // milliseconds\n    this.SMOKE_LIFETIME = 3000; // milliseconds\n\n    // Create a variable called wobble that tweens back and forth between\n    // -this.WOBBLE_LIMIT and +this.WOBBLE_LIMIT forever\n    this.wobble = this.WOBBLE_LIMIT;\n    this.game.add.tween(this)\n        .to(\n            { wobble: -this.WOBBLE_LIMIT },\n            this.WOBBLE_SPEED, Phaser.Easing.Sinusoidal.InOut, true, 0,\n            Number.POSITIVE_INFINITY, true\n        );\n\n    // Add a smoke emitter with 100 particles positioned relative to the\n    // bottom center of this missile\n    this.smokeEmitter = this.game.add.emitter(0, 0, 100);\n\n    // Set motion parameters for the emitted particles\n    this.smokeEmitter.gravity = 0;\n    this.smokeEmitter.setXSpeed(0, 0);\n    this.smokeEmitter.setYSpeed(-80, -50); // make smoke drift upwards\n\n    // Make particles fade out after 1000ms\n    this.smokeEmitter.setAlpha(1, 0, this.SMOKE_LIFETIME, Phaser.Easing.Linear.InOut);\n\n    // Create the actual particles\n    this.smokeEmitter.makeParticles('smoke');\n\n    // Start emitting smoke particles one at a time (explode=false) with a\n    // lifespan of this.SMOKE_LIFETIME at 50ms intervals\n    this.smokeEmitter.start(false, this.SMOKE_LIFETIME, 50);\n};\n\n// Missiles are a type of Phaser.Sprite\nMissile.prototype = Object.create(Phaser.Sprite.prototype);\nMissile.prototype.constructor = Missile;\n\nMissile.prototype.update = function() {\n    // If this missile is dead, don't do any of these calculations\n    // Also, turn off the smoke emitter\n    if (!this.alive) {\n        this.smokeEmitter.on = false;\n        return;\n    } else {\n        this.smokeEmitter.on = true;\n    }\n\n    // Position the smoke emitter at the center of the missile\n    this.smokeEmitter.x = this.x;\n    this.smokeEmitter.y = this.y;\n\n    // Calculate the angle from the missile to the mouse cursor game.input.x\n    // and game.input.y are the mouse position; substitute with whatever\n    // target coordinates you need.\n    var targetAngle = this.game.math.angleBetween(\n        this.x, this.y,\n        this.game.input.activePointer.x, this.game.input.activePointer.y\n    );\n\n    // Add our \"wobble\" factor to the targetAngle to make the missile wobble\n    // Remember that this.wobble is tweening (above)\n    targetAngle += this.game.math.degToRad(this.wobble);\n\n    // Gradually (this.TURN_RATE) aim the missile towards the target angle\n    if (this.rotation !== targetAngle) {\n        // Calculate difference between the current angle and targetAngle\n        var delta = targetAngle - this.rotation;\n\n        // Keep it in range from -180 to 180 to make the most efficient turns.\n        if (delta > Math.PI) delta -= Math.PI * 2;\n        if (delta < -Math.PI) delta += Math.PI * 2;\n\n        if (delta > 0) {\n            // Turn clockwise\n            this.angle += this.TURN_RATE;\n        } else {\n            // Turn counter-clockwise\n            this.angle -= this.TURN_RATE;\n        }\n\n        // Just set angle to target angle if they are close\n        if (Math.abs(delta) < this.game.math.degToRad(this.TURN_RATE)) {\n            this.rotation = targetAngle;\n        }\n    }\n\n    // Calculate velocity vector based on this.rotation and this.SPEED\n    this.body.velocity.x = Math.cos(this.rotation) * this.SPEED;\n    this.body.velocity.y = Math.sin(this.rotation) * this.SPEED;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "explosions": {
                    "notes": "The missile will target the pointer (or tap). Move the pointer around the example area.\n\nMissiles explode when they get within a specific distance of the target. This example introduces a function getExplosion() which either creates a new explosion object or re-uses one that was created earlier. This approach allows the number of explosion sprites to increase dynamically but never creates more than are needed to display on screen at any one time. Rockets are recycled in exactly the same way.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('rocket', '/assets/gfx/rocket.png');\n    this.game.load.image('smoke', '/assets/gfx/smoke.png');\n\n    this.game.load.spritesheet('explosion', '/assets/gfx/explosion.png', 128, 128);\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create a group to hold the missile\n    this.missileGroup = this.game.add.group();\n\n    // Create a group for explosions\n    this.explosionGroup = this.game.add.group();\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.activePointer.x = this.game.width/2;\n    this.game.input.activePointer.y = this.game.height/2 - 100;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // If there aren't any missiles, launch one\n    if (this.missileGroup.countLiving() === 0) {\n        this.launchMissile(this.game.width/2, this.game.height - 16);\n    }\n\n    // If any missile is within a certain distance of the mouse pointer, blow it up\n    this.missileGroup.forEachAlive(function(m) {\n        var distance = this.game.math.distance(m.x, m.y,\n            this.game.input.activePointer.x, this.game.input.activePointer.y);\n        if (distance < 50) {\n            m.kill();\n            this.getExplosion(m.x, m.y);\n        }\n    }, this);\n};\n\n// Try to get a missile from the missileGroup\n// If a missile isn't available, create a new one and add it to the group.\nGameState.prototype.launchMissile = function(x, y) {\n    // // Get the first dead missile from the missileGroup\n    var missile = this.missileGroup.getFirstDead();\n\n    // If there aren't any available, create a new one\n    if (missile === null) {\n        missile = new Missile(this.game);\n        this.missileGroup.add(missile);\n    }\n\n    // Revive the missile (set it's alive property to true)\n    // You can also define a onRevived event handler in your explosion objects\n    // to do stuff when they are revived.\n    missile.revive();\n\n    // Move the missile to the given coordinates\n    missile.x = x;\n    missile.y = y;\n\n    return missile;\n};\n\n// Try to get a used explosion from the explosionGroup.\n// If an explosion isn't available, create a new one and add it to the group.\n// Setup new explosions so that they animate and kill themselves when the\n// animation is complete.\nGameState.prototype.getExplosion = function(x, y) {\n    // Get the first dead explosion from the explosionGroup\n    var explosion = this.explosionGroup.getFirstDead();\n\n    // If there aren't any available, create a new one\n    if (explosion === null) {\n        explosion = this.game.add.sprite(0, 0, 'explosion');\n        explosion.anchor.setTo(0.5, 0.5);\n\n        // Add an animation for the explosion that kills the sprite when the\n        // animation is complete\n        var animation = explosion.animations.add('boom', [0,1,2,3], 60, false);\n        animation.killOnComplete = true;\n\n        // Add the explosion sprite to the group\n        this.explosionGroup.add(explosion);\n    }\n\n    // Revive the explosion (set it's alive property to true)\n    // You can also define a onRevived event handler in your explosion objects\n    // to do stuff when they are revived.\n    explosion.revive();\n\n    // Move the explosion to the given coordinates\n    explosion.x = x;\n    explosion.y = y;\n\n    // Set rotation of the explosion at random for a little variety\n    explosion.angle = this.game.rnd.integerInRange(0, 360);\n\n    // Play the animation\n    explosion.animations.play('boom');\n\n    // Return the explosion itself in case we want to do anything else with it\n    return explosion;\n};\n\n// Missile constructor\nvar Missile = function(game, x, y) {\n    Phaser.Sprite.call(this, game, x, y, 'rocket');\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on the missile\n    this.game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Define constants that affect motion\n    this.SPEED = 250; // missile speed pixels/second\n    this.TURN_RATE = 5; // turn rate in degrees/frame\n    this.WOBBLE_LIMIT = 15; // degrees\n    this.WOBBLE_SPEED = 250; // milliseconds\n    this.SMOKE_LIFETIME = 3000; // milliseconds\n\n    // Create a variable called wobble that tweens back and forth between\n    // -this.WOBBLE_LIMIT and +this.WOBBLE_LIMIT forever\n    this.wobble = this.WOBBLE_LIMIT;\n    this.game.add.tween(this)\n        .to(\n            { wobble: -this.WOBBLE_LIMIT },\n            this.WOBBLE_SPEED, Phaser.Easing.Sinusoidal.InOut, true, 0,\n            Number.POSITIVE_INFINITY, true\n        );\n\n    // Add a smoke emitter with 100 particles positioned relative to the bottom\n    // center of this missile\n    this.smokeEmitter = this.game.add.emitter(0, 0, 100);\n\n    // Set motion parameters for the emitted particles\n    this.smokeEmitter.gravity = 0;\n    this.smokeEmitter.setXSpeed(0, 0);\n    this.smokeEmitter.setYSpeed(-80, -50); // make smoke drift upwards\n\n    // Make particles fade out after 1000ms\n    this.smokeEmitter.setAlpha(1, 0, this.SMOKE_LIFETIME,\n        Phaser.Easing.Linear.InOut);\n\n    // Create the actual particles\n    this.smokeEmitter.makeParticles('smoke');\n\n    // Start emitting smoke particles one at a time (explode=false) with a\n    // lifespan of this.SMOKE_LIFETIME at 50ms intervals\n    this.smokeEmitter.start(false, this.SMOKE_LIFETIME, 50);\n};\n\n// Missiles are a type of Phaser.Sprite\nMissile.prototype = Object.create(Phaser.Sprite.prototype);\nMissile.prototype.constructor = Missile;\n\nMissile.prototype.update = function() {\n    // If this missile is dead, don't do any of these calculations\n    // Also, turn off the smoke emitter\n    if (!this.alive) {\n        this.smokeEmitter.on = false;\n        return;\n    } else {\n        this.smokeEmitter.on = true;\n    }\n\n    // Position the smoke emitter at the center of the missile\n    this.smokeEmitter.x = this.x;\n    this.smokeEmitter.y = this.y;\n\n    // Calculate the angle from the missile to the mouse cursor game.input.x\n    // and game.input.y are the mouse position; substitute with whatever\n    // target coordinates you need.\n    var targetAngle = this.game.math.angleBetween(\n        this.x, this.y,\n        this.game.input.activePointer.x, this.game.input.activePointer.y\n    );\n\n    // Add our \"wobble\" factor to the targetAngle to make the missile wobble\n    // Remember that this.wobble is tweening (above)\n    targetAngle += this.game.math.degToRad(this.wobble);\n\n    // Gradually (this.TURN_RATE) aim the missile towards the target angle\n    if (this.rotation !== targetAngle) {\n        // Calculate difference between the current angle and targetAngle\n        var delta = targetAngle - this.rotation;\n\n        // Keep it in range from -180 to 180 to make the most efficient turns.\n        if (delta > Math.PI) delta -= Math.PI * 2;\n        if (delta < -Math.PI) delta += Math.PI * 2;\n\n        if (delta > 0) {\n            // Turn clockwise\n            this.angle += this.TURN_RATE;\n        } else {\n            // Turn counter-clockwise\n            this.angle -= this.TURN_RATE;\n        }\n\n        // Just set angle to target angle if they are close\n        if (Math.abs(delta) < this.game.math.degToRad(this.TURN_RATE)) {\n            this.rotation = targetAngle;\n        }\n    }\n\n    // Calculate velocity vector based on this.rotation and this.SPEED\n    this.body.velocity.x = Math.cos(this.rotation) * this.SPEED;\n    this.body.velocity.y = Math.sin(this.rotation) * this.SPEED;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "flocking": {
                    "notes": "The missiles will target the pointer (or tap). Move the pointer around the example area.\n\nThe last example was fine but it is possible to get the missiles to bunch up and begin to follow exactly the same path. One way to solve that problem is to make each missile keep its distance from its neighbors. In this example the missiles attempt to steer away from other missiles that are too close. Each missile calculates the distance to every other missile and attempts to steer 90 degrees away from close ones.\n\nLook at the code for avoidAngle for the implementation.\n\nThis looks like a lot of math to be doing every frame for every missile. But profiling shows that this has almost no effect on frame rate (4% per frame for 100 missiles on my desktop). The biggest impact on frame rate is the number of smoke particles per missile.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n    this.MAX_MISSILES = 10; // number of missiles\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('rocket', '/assets/gfx/rocket.png');\n    this.game.load.image('smoke', '/assets/gfx/smoke.png');\n\n    this.game.load.spritesheet('explosion', '/assets/gfx/explosion.png', 128, 128);\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create a group to hold the missile\n    this.missileGroup = this.game.add.group();\n\n    // Create a group for explosions\n    this.explosionGroup = this.game.add.group();\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.activePointer.x = this.game.width/2;\n    this.game.input.activePointer.y = this.game.height/2 - 100;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n    // If there are fewer than MAX_MISSILES, launch a new one\n    if (this.missileGroup.countLiving() < this.MAX_MISSILES) {\n        // Set the launch point to a random location below the bottom edge\n        // of the stage\n        this.launchMissile(this.game.rnd.integerInRange(50, this.game.width-50),\n            this.game.height + 50);\n    }\n\n    // If any missile is within a certain distance of the mouse pointer, blow it up\n    this.missileGroup.forEachAlive(function(m) {\n        var distance = this.game.math.distance(m.x, m.y,\n            this.game.input.activePointer.x, this.game.input.activePointer.y);\n        if (distance < 50) {\n            m.kill();\n            this.getExplosion(m.x, m.y);\n        }\n    }, this);\n};\n\n// Try to get a missile from the missileGroup\n// If a missile isn't available, create a new one and add it to the group.\nGameState.prototype.launchMissile = function(x, y) {\n    // // Get the first dead missile from the missileGroup\n    var missile = this.missileGroup.getFirstDead();\n\n    // If there aren't any available, create a new one\n    if (missile === null) {\n        missile = new Missile(this.game);\n        this.missileGroup.add(missile);\n    }\n\n    // Revive the missile (set it's alive property to true)\n    // You can also define a onRevived event handler in your explosion objects\n    // to do stuff when they are revived.\n    missile.revive();\n\n    // Move the missile to the given coordinates\n    missile.x = x;\n    missile.y = y;\n\n    return missile;\n};\n\n// Try to get a used explosion from the explosionGroup.\n// If an explosion isn't available, create a new one and add it to the group.\n// Setup new explosions so that they animate and kill themselves when the\n// animation is complete.\nGameState.prototype.getExplosion = function(x, y) {\n    // Get the first dead explosion from the explosionGroup\n    var explosion = this.explosionGroup.getFirstDead();\n\n    // If there aren't any available, create a new one\n    if (explosion === null) {\n        explosion = this.game.add.sprite(0, 0, 'explosion');\n        explosion.anchor.setTo(0.5, 0.5);\n\n        // Add an animation for the explosion that kills the sprite when the\n        // animation is complete\n        var animation = explosion.animations.add('boom', [0,1,2,3], 60, false);\n        animation.killOnComplete = true;\n\n        // Add the explosion sprite to the group\n        this.explosionGroup.add(explosion);\n    }\n\n    // Revive the explosion (set it's alive property to true)\n    // You can also define a onRevived event handler in your explosion objects\n    // to do stuff when they are revived.\n    explosion.revive();\n\n    // Move the explosion to the given coordinates\n    explosion.x = x;\n    explosion.y = y;\n\n    // Set rotation of the explosion at random for a little variety\n    explosion.angle = this.game.rnd.integerInRange(0, 360);\n\n    // Play the animation\n    explosion.animations.play('boom');\n\n    // Return the explosion itself in case we want to do anything else with it\n    return explosion;\n};\n\n// Missile constructor\nvar Missile = function(game, x, y) {\n    Phaser.Sprite.call(this, game, x, y, 'rocket');\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on the missile\n    this.game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Define constants that affect motion\n    this.SPEED = 250; // missile speed pixels/second\n    this.TURN_RATE = 5; // turn rate in degrees/frame\n    this.WOBBLE_LIMIT = 15; // degrees\n    this.WOBBLE_SPEED = 250; // milliseconds\n    this.SMOKE_LIFETIME = 3000; // milliseconds\n    this.AVOID_DISTANCE = 30; // pixels\n\n    // Create a variable called wobble that tweens back and forth between\n    // -this.WOBBLE_LIMIT and +this.WOBBLE_LIMIT forever\n    this.wobble = this.WOBBLE_LIMIT;\n    this.game.add.tween(this)\n        .to(\n            { wobble: -this.WOBBLE_LIMIT },\n            this.WOBBLE_SPEED, Phaser.Easing.Sinusoidal.InOut, true, 0,\n            Number.POSITIVE_INFINITY, true\n        );\n\n    // Add a smoke emitter with 100 particles positioned relative to the\n    // bottom center of this missile\n    this.smokeEmitter = this.game.add.emitter(0, 0, 100);\n\n    // Set motion parameters for the emitted particles\n    this.smokeEmitter.gravity = 0;\n    this.smokeEmitter.setXSpeed(0, 0);\n    this.smokeEmitter.setYSpeed(-80, -50); // make smoke drift upwards\n\n    // Make particles fade out after 1000ms\n    this.smokeEmitter.setAlpha(1, 0, this.SMOKE_LIFETIME,\n        Phaser.Easing.Linear.InOut);\n\n    // Create the actual particles\n    this.smokeEmitter.makeParticles('smoke');\n\n    // Start emitting smoke particles one at a time (explode=false) with a\n    // lifespan of this.SMOKE_LIFETIME at 50ms intervals\n    this.smokeEmitter.start(false, this.SMOKE_LIFETIME, 50);\n};\n\n// Missiles are a type of Phaser.Sprite\nMissile.prototype = Object.create(Phaser.Sprite.prototype);\nMissile.prototype.constructor = Missile;\n\nMissile.prototype.update = function() {\n    // If this missile is dead, don't do any of these calculations\n    // Also, turn off the smoke emitter\n    if (!this.alive) {\n        this.smokeEmitter.on = false;\n        return;\n    } else {\n        this.smokeEmitter.on = true;\n    }\n\n    // Position the smoke emitter at the center of the missile\n    this.smokeEmitter.x = this.x;\n    this.smokeEmitter.y = this.y;\n\n    // Calculate the angle from the missile to the mouse cursor game.input.x\n    // and game.input.y are the mouse position; substitute with whatever\n    // target coordinates you need.\n    var targetAngle = this.game.math.angleBetween(\n        this.x, this.y,\n        this.game.input.activePointer.x, this.game.input.activePointer.y\n    );\n\n    // Add our \"wobble\" factor to the targetAngle to make the missile wobble\n    // Remember that this.wobble is tweening (above)\n    targetAngle += this.game.math.degToRad(this.wobble);\n\n\n    // Make each missile steer away from other missiles.\n    // Each missile knows the group that it belongs to (missileGroup).\n    // It can calculate its distance from all other missiles in the group and\n    // steer away from any that are too close. This avoidance behavior prevents\n    // all of the missiles from bunching up too tightly and following the\n    // same track.\n    var avoidAngle = 0;\n    this.parent.forEachAlive(function(m) {\n        // Don't calculate anything if the other missile is me\n        if (this == m) return;\n\n        // Already found an avoidAngle so skip the rest\n        if (avoidAngle !== 0) return;\n\n        // Calculate the distance between me and the other missile\n        var distance = this.game.math.distance(this.x, this.y, m.x, m.y);\n\n        // If the missile is too close...\n        if (distance < this.AVOID_DISTANCE) {\n            // Chose an avoidance angle of 90 or -90 (in radians)\n            avoidAngle = Math.PI/2; // zig\n            if (this.game.math.chanceRoll(50)) avoidAngle *= -1; // zag\n        }\n    }, this);\n\n    // Add the avoidance angle to steer clear of other missiles\n    targetAngle += avoidAngle;\n\n    // Gradually (this.TURN_RATE) aim the missile towards the target angle\n    if (this.rotation !== targetAngle) {\n        // Calculate difference between the current angle and targetAngle\n        var delta = targetAngle - this.rotation;\n\n        // Keep it in range from -180 to 180 to make the most efficient turns.\n        if (delta > Math.PI) delta -= Math.PI * 2;\n        if (delta < -Math.PI) delta += Math.PI * 2;\n\n        if (delta > 0) {\n            // Turn clockwise\n            this.angle += this.TURN_RATE;\n        } else {\n            // Turn counter-clockwise\n            this.angle -= this.TURN_RATE;\n        }\n\n        // Just set angle to target angle if they are close\n        if (Math.abs(delta) < this.game.math.degToRad(this.TURN_RATE)) {\n            this.rotation = targetAngle;\n        }\n    }\n\n    // Calculate velocity vector based on this.rotation and this.SPEED\n    this.body.velocity.x = Math.cos(this.rotation) * this.SPEED;\n    this.body.velocity.y = Math.sin(this.rotation) * this.SPEED;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "basic_missile": {
                    "notes": "This example implements a basic homing missile algorithm. The missile will automatically steer itself towards the pointer (or tap). Move the pointer around the example area. The missile's turning radius is determined by the variables this.SPEED and this.TURN_RATE.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('rocket', '/assets/gfx/rocket.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create a missile and add it to the game in the bottom center of the stage\n    this.game.add.existing(\n        new Missile(this.game, this.game.width/2, this.game.height - 16)\n    );\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.activePointer.x = this.game.width/2;\n    this.game.input.activePointer.y = this.game.height/2 - 100;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n};\n\n// Missile constructor\nvar Missile = function(game, x, y) {\n    Phaser.Sprite.call(this, game, x, y, 'rocket');\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on the missile\n    game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Define constants that affect motion\n    this.SPEED = 250; // missile speed pixels/second\n    this.TURN_RATE = 5; // turn rate in degrees/frame\n};\n\n// Missiles are a type of Phaser.Sprite\nMissile.prototype = Object.create(Phaser.Sprite.prototype);\nMissile.prototype.constructor = Missile;\n\nMissile.prototype.update = function() {\n    // Calculate the angle from the missile to the mouse cursor game.input.x\n    // and game.input.y are the mouse position; substitute with whatever\n    // target coordinates you need.\n    var targetAngle = this.game.math.angleBetween(\n        this.x, this.y,\n        this.game.input.activePointer.x, this.game.input.activePointer.y\n    );\n\n    // Gradually (this.TURN_RATE) aim the missile towards the target angle\n    if (this.rotation !== targetAngle) {\n        // Calculate difference between the current angle and targetAngle\n        var delta = targetAngle - this.rotation;\n\n        // Keep it in range from -180 to 180 to make the most efficient turns.\n        if (delta > Math.PI) delta -= Math.PI * 2;\n        if (delta < -Math.PI) delta += Math.PI * 2;\n\n        if (delta > 0) {\n            // Turn clockwise\n            this.angle += this.TURN_RATE;\n        } else {\n            // Turn counter-clockwise\n            this.angle -= this.TURN_RATE;\n        }\n\n        // Just set angle to target angle if they are close\n        if (Math.abs(delta) < this.game.math.degToRad(this.TURN_RATE)) {\n            this.rotation = targetAngle;\n        }\n    }\n\n    // Calculate velocity vector based on this.rotation and this.SPEED\n    this.body.velocity.x = Math.cos(this.rotation) * this.SPEED;\n    this.body.velocity.y = Math.sin(this.rotation) * this.SPEED;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "missile_with_wobble": {
                    "notes": "The missile will target the pointer (or tap). Move the pointer around the example area.\n\nThis example adds a neat little wobble to the straight line motion of the missile. It's purely visual but adds a lot of character. The wobble is implemented as a variable this.wobble that tweens back and forth between two values.\n\n",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('rocket', '/assets/gfx/rocket.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create a missile and add it to the game in the bottom center of the stage\n    this.game.add.existing(\n        new Missile(this.game, this.game.width/2, this.game.height - 16)\n    );\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.activePointer.x = this.game.width/2;\n    this.game.input.activePointer.y = this.game.height/2 - 100;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n};\n\n// Missile constructor\nvar Missile = function(game, x, y) {\n    Phaser.Sprite.call(this, game, x, y, 'rocket');\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on the missile\n    this.game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Define constants that affect motion\n    this.SPEED = 250; // missile speed pixels/second\n    this.TURN_RATE = 5; // turn rate in degrees/frame\n    this.WOBBLE_LIMIT = 15; // degrees\n    this.WOBBLE_SPEED = 250; // milliseconds\n\n    // Create a variable called wobble that tweens back and forth between\n    // -this.WOBBLE_LIMIT and +this.WOBBLE_LIMIT forever\n    this.wobble = this.WOBBLE_LIMIT;\n    this.game.add.tween(this)\n        .to(\n            { wobble: -this.WOBBLE_LIMIT },\n            this.WOBBLE_SPEED, Phaser.Easing.Sinusoidal.InOut, true, 0,\n            Number.POSITIVE_INFINITY, true\n        );\n};\n\n// Missiles are a type of Phaser.Sprite\nMissile.prototype = Object.create(Phaser.Sprite.prototype);\nMissile.prototype.constructor = Missile;\n\nMissile.prototype.update = function() {\n    // Calculate the angle from the missile to the mouse cursor game.input.x\n    // and game.input.y are the mouse position; substitute with whatever\n    // target coordinates you need.\n    var targetAngle = this.game.math.angleBetween(\n        this.x, this.y,\n        this.game.input.activePointer.x, this.game.input.activePointer.y\n    );\n\n    // Add our \"wobble\" factor to the targetAngle to make the missile wobble\n    // Remember that this.wobble is tweening (above)\n    targetAngle += this.game.math.degToRad(this.wobble);\n\n    // Gradually (this.TURN_RATE) aim the missile towards the target angle\n    if (this.rotation !== targetAngle) {\n        // Calculate difference between the current angle and targetAngle\n        var delta = targetAngle - this.rotation;\n\n        // Keep it in range from -180 to 180 to make the most efficient turns.\n        if (delta > Math.PI) delta -= Math.PI * 2;\n        if (delta < -Math.PI) delta += Math.PI * 2;\n\n        if (delta > 0) {\n            // Turn clockwise\n            this.angle += this.TURN_RATE;\n        } else {\n            // Turn counter-clockwise\n            this.angle -= this.TURN_RATE;\n        }\n\n        // Just set angle to target angle if they are close\n        if (Math.abs(delta) < this.game.math.degToRad(this.TURN_RATE)) {\n            this.rotation = targetAngle;\n        }\n    }\n\n    // Calculate velocity vector based on this.rotation and this.SPEED\n    this.body.velocity.x = Math.cos(this.rotation) * this.SPEED;\n    this.body.velocity.y = Math.sin(this.rotation) * this.SPEED;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                },
                "smoke_trails": {
                    "notes": "The missile will target the pointer (or tap). Move the pointer around the example area.\n\nWhat's a missile without a smoke trail? A simple particle emitter is attached to the tail of the missile. The tricky part is continuously repositioning the emitter at the tail of the rocket in Missile.prototype.update.",
                    "source": "// This example uses the Phaser 2.2.2 framework\n\n// Copyright \u00a9 2014 John Watson\n// Licensed under the terms of the MIT License\n\nvar GameState = function(game) {\n};\n\n// Load images and sounds\nGameState.prototype.preload = function() {\n    this.game.load.image('rocket', '/assets/gfx/rocket.png');\n    this.game.load.image('smoke', '/assets/gfx/smoke.png');\n};\n\n// Setup the example\nGameState.prototype.create = function() {\n    // Set stage background to something sky colored\n    this.game.stage.backgroundColor = 0x4488cc;\n\n    // Create a missile and add it to the game in the bottom center of the stage\n    this.game.add.existing(\n        new Missile(this.game, this.game.width/2, this.game.height - 16)\n    );\n\n    // Simulate a pointer click/tap input at the center of the stage\n    // when the example begins running.\n    this.game.input.activePointer.x = this.game.width/2;\n    this.game.input.activePointer.y = this.game.height/2 - 100;\n};\n\n// The update() method is called every frame\nGameState.prototype.update = function() {\n};\n\n// Missile constructor\nvar Missile = function(game, x, y) {\n    Phaser.Sprite.call(this, game, x, y, 'rocket');\n\n    // Set the pivot point for this sprite to the center\n    this.anchor.setTo(0.5, 0.5);\n\n    // Enable physics on the missile\n    this.game.physics.enable(this, Phaser.Physics.ARCADE);\n\n    // Define constants that affect motion\n    this.SPEED = 250; // missile speed pixels/second\n    this.TURN_RATE = 5; // turn rate in degrees/frame\n    this.WOBBLE_LIMIT = 15; // degrees\n    this.WOBBLE_SPEED = 250; // milliseconds\n    this.SMOKE_LIFETIME = 3000; // milliseconds\n\n    // Create a variable called wobble that tweens back and forth between\n    // -this.WOBBLE_LIMIT and +this.WOBBLE_LIMIT forever\n    this.wobble = this.WOBBLE_LIMIT;\n    this.game.add.tween(this)\n        .to(\n            { wobble: -this.WOBBLE_LIMIT },\n            this.WOBBLE_SPEED, Phaser.Easing.Sinusoidal.InOut, true, 0,\n            Number.POSITIVE_INFINITY, true\n        );\n\n    // Add a smoke emitter with 100 particles positioned relative to the\n    // bottom center of this missile\n    this.smokeEmitter = this.game.add.emitter(0, 0, 100);\n\n    // Set motion paramters for the emitted particles\n    this.smokeEmitter.gravity = 0;\n    this.smokeEmitter.setXSpeed(0, 0);\n    this.smokeEmitter.setYSpeed(-80, -50); // make smoke drift upwards\n\n    // Make particles fade out after 1000ms\n    this.smokeEmitter.setAlpha(1, 0, this.SMOKE_LIFETIME,\n        Phaser.Easing.Linear.InOut);\n\n    // Create the actual particles\n    this.smokeEmitter.makeParticles('smoke');\n\n    // Start emitting smoke particles one at a time (explode=false) with a\n    // lifespan of this.SMOKE_LIFETIME at 50ms intervals\n    this.smokeEmitter.start(false, this.SMOKE_LIFETIME, 50);\n};\n\n// Missiles are a type of Phaser.Sprite\nMissile.prototype = Object.create(Phaser.Sprite.prototype);\nMissile.prototype.constructor = Missile;\n\nMissile.prototype.update = function() {\n    // Position the smoke emitter at the center of the missile\n    this.smokeEmitter.x = this.x;\n    this.smokeEmitter.y = this.y;\n\n    // Calculate the angle from the missile to the mouse cursor game.input.x\n    // and game.input.y are the mouse position; substitute with whatever\n    // target coordinates you need.\n    var targetAngle = this.game.math.angleBetween(\n        this.x, this.y,\n        this.game.input.activePointer.x, this.game.input.activePointer.y\n    );\n\n    // Add our \"wobble\" factor to the targetAngle to make the missile wobble\n    // Remember that this.wobble is tweening (above)\n    targetAngle += this.game.math.degToRad(this.wobble);\n\n    // Gradually (this.TURN_RATE) aim the missile towards the target angle\n    if (this.rotation !== targetAngle) {\n        // Calculate difference between the current angle and targetAngle\n        var delta = targetAngle - this.rotation;\n\n        // Keep it in range from -180 to 180 to make the most efficient turns.\n        if (delta > Math.PI) delta -= Math.PI * 2;\n        if (delta < -Math.PI) delta += Math.PI * 2;\n\n        if (delta > 0) {\n            // Turn clockwise\n            this.angle += this.TURN_RATE;\n        } else {\n            // Turn counter-clockwise\n            this.angle -= this.TURN_RATE;\n        }\n\n        // Just set angle to target angle if they are close\n        if (Math.abs(delta) < this.game.math.degToRad(this.TURN_RATE)) {\n            this.rotation = targetAngle;\n        }\n    }\n\n    // Calculate velocity vector based on this.rotation and this.SPEED\n    this.body.velocity.x = Math.cos(this.rotation) * this.SPEED;\n    this.body.velocity.y = Math.sin(this.rotation) * this.SPEED;\n};\n\nvar game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');\ngame.state.add('game', GameState, true);"
                }
            },
            "assets": [
                "/assets/gfx/rocket.png",
                "/assets/gfx/smoke.png",
                "/assets/gfx/explosion.png"
            ]
        }
    }
}